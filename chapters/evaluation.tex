\فصل{پیاده سازی}
دستاورد های این فصل به شرح زیر است:\\
1) با استفاده از \کد{dynamic programming} الگوریتمی برای پیدا کردن جواب بهینه آفلاین \off برای مساله کانال های دو طرفه ارائه میدهیم. توجه کنید که جواب بهینه آفلاین برای این مساله \کد{NP-Hard} است 
~\cite{oracle}
و در نتیجه پیاده سازی آن برای دنباله های تراکنش طولانی بهینه نیست، با این وجود در این بخش این الگوریتم را برای دنباله تراکنش های به نسبت کوتاه پیاده سازی میکنیم تا بتوانیم هزینه آن را در عمل با هزینه الگوریتم آنلاینی که در فصل \رجوع{فصل:نتایج تئوری} طراحی کرده ایم مقایسه کنیم.\\
2) الگوریتم آنلاین مساله کانال های دو طرفه که ضریب رقابتی آن را در فصل \رجوع{فصل:نتایج تئوری} اثبات کردیم پیاده سازی میکنیم و ضریب رقابتی آن را در عمل پیدا کرده و با نتایج تئوری مقایسه میکنیم.\\
3) پارامتر های توابع هزینه مدلمان را برای \کد{Lightning Network}که یک نمونه ی عملی شده و پرکاربر شبکه کانال های پرداخت است پیدا میکنیم.

\قسمت{پیدا کردن الگوریتم \off به کمک \کد{dynamic programming}} \برچسب{قسمت:پیدا کردن الگوریتم آف}
برای دنباله تراکنش
$X_i$
تابع 
$\textsc{Cost}_i^{rej+reb}(F_{\ell},F_{r})$
را تعریف میکنیم. این تابع نمایانگر مینیمم هزینه ممکن رد کردن تراکنش (\کد{rej}) و متعادل کردن برون بلاکچینی  (\کد{reb}) الگوریتمی است که دنباله تراکنش
$X_i$
را پردازش میکند به طوریکه پس از پردازش
$x_i$
موجودی سمت چپ کانال برابر با
$b(\ell)=F_{\ell} \geq 0$
و موجودی سمت راست کانال برابر
$b(r)=F_{r} \geq 0$
باشد.
با داشتن 
$\textsc{Cost}_{i-1}^{rej+reb}(.,.)$
برای مقادیر مختلف
$F_{\ell}$
و
$F_{r}$
میتوان 
$\textsc{Cost}_{i}^{rej+reb}(F_{\ell},F_{r})$
را با بررسی اکشن های مختلف الگوریتم برای تراکنش 
$i$
ام محاسبه کرد. بدون از دست دادن عمومیت حالتی را که تراکنش
$x_i$
از چپ به راست است را بررسی میکنیم. برای تراکنش از راست به چپ هم دقیقا مشابه همین حالت بندی ها را میتوان انجام داد.\\
1) اگر الگوریتم تراکنش $i$ ام را رد کند آن گاه موجودی طرفین کانال در دو لحظه
$i-1$
و 
$i$
مشابه هم است و میتوان نوشت:
\begin{equation}
\textsc{Cost}_{i}^{rej+reb}(F_{\ell},F_{r}|rej) \coloneq \textsc{Cost}_{i-1}^{rej+reb}(F_{\ell},F_{r}) + Rx_i+f_2
\end{equation}
2) اگر الگوریتم تراکنش 
$i$
را بپذیرد بدون اینکه پیش از آن متعادل کردن برون بلاکچینی انجام دهد، آنگاه پردازش تراکنش هزینه ای ندارد اما موجودی طرفین کانال پس از پذیرش تراکنش تغییر میکند.
\begin{equation}
\textsc{Cost}_{i}^{rej+reb}(F_{\ell},F_{r}|acc) \coloneq \\
    \begin{cases}
       \textsc{Cost}_{i-1}^{rej+reb}(F_{\ell}+x_i,F_{r}-x_i) & \text{If } \; F_{r} > x_i  \\
        \infty & \text{O.W. }
    \end{cases}       
\end{equation}
3) اگر الگوریتم ابتدا متعادل کردن برون بلاکچینی انجام دهد و بعد تراکنش
$i$
را بپذیرد میتوان هزینه الگوریتم را بر حسب مقدار جابجایی پول در حین متعادل کردن به صورت زیر نوشت:
\begin{equation}
\textsc{Cost}_{i}^{rej+reb}(F_{\ell},F_{r}|reb)  \coloneq \\
    \begin{cases}
       \min_{a \le F_{\ell} + x_i}  \textsc{Cost}_{i-1}^{rej+reb}(a, F_r+ F_{\ell} - a) + C\cdot R(F_{\ell} + x_i - a)+Cf_2 & \text{If } \; F_{r} > x_i  \\
        \infty & \text{O.W. }
    \end{cases}       
\end{equation}
دقت کنید که الگوریتم بهینه متعادل کردن برون بلاکچینی را تا آخرین لحظه ای که برای پردازش تراکنشی به پول بیشتر نیاز دارد به تعویق می اندازد، پس میتوان فرض کرد اگر الگوریتم تنها زمانی متعادل کردن برون بلاکچینی از راست به چپ انجام میدهد که میخواهد تراکنشی از چپ به راست را بپذیرد.
الگوریتم بهینه برای تصمیم گیری درباره هر تراکنش، هزینه اکشن های ذکر شده را مقایسه میکند و بهترین را بر میگزیند یعنی:
\begin{equation}\label{eq:dynamic_prog_costrejreb}
\textsc{Cost}_{i}^{rej+reb}(F_{\ell},F_{r}) = \min\{\textsc{Cost}_{i}^{rej+reb}(F_{\ell},F_{r}|rej), \textsc{Cost}_{i}^{rej+reb}(F_{\ell},F_{r}|acc), \textsc{Cost}_{i}^{rej+reb}(F_{\ell},F_{r}|reb) \}
\end{equation}
 از طرفی دقت کنید که در تابع
$\textsc{Cost}_{i}^{rej+reb}(.,.)$
هزینه شارژ کردن درون بلاکچینی را در نظر نگرفتیم، اما \off این هزینه را هم در نظر میگیرد. پس \off از بین همه 
$F_{\ell}$
و
$F_r$
های ممکن آنهایی را برمی گزیند که مجموع همه هزینه ها را کمینه میکنند. به علاوه \off هزینه حالتی که همه تراکنش ها را هم رد کند و 
$F_{\ell}$
و
$F_r$
هر دو صفر باشند را هم در بین گزینه هایش در نظر میگیرد چون ممکن است برای برخی از دنباله های تراکنش ها اصولا شارژ کردن کانال به هیچ وجه توجیه پذیر نباشد.
\begin{equation}\label{eq:dynamic_prog_costoff}
\costoff(X_i)  = \min\{\min_{F_{\ell},F_r \geq 0}  \textsc{Cost}_{t}^{rej+reb}(F_{\ell},F_{r}) + F_{\ell} + F_{r} + f_1, \sum_{i \in [1,t]} (R|x_i|+f_2)\}
\end{equation}
دقت کنید که \off چون از پیش به کل دنباله تراکنش دسترسی دارد، عمل شارژ کردن را حداکثر یکبار همان ابتدا انجام میدهد و کانال را دقیقا به میزانی که تا انتها نیاز خواهد داشت شارژ میکند تا فقط یکبار هزینه
$f_1$
را بپردازد.

چندین نکته را باید در خصوص معادله  \رجوع{eq:dynamic_prog_costoff} در نظر گرفت:\\
1) برای اینکه بتوان مینیمم سازی معادله \رجوع{eq:dynamic_prog_costoff} را در عمل محاسبه کرد، باید مقادیر تراکنش ها گسسته باشد تا در نتیجه بتوان 
$F_{\ell}$
و
$F_r$
را هم گسسته در نظر گرفت و برای کمینه کردن تابع هزینه روی یک فضای گسسته متناهی جستجو انجام داد. به همین منظور در این بخش برای سادگی فرض میکنیم که تراکنش ها اعداد طبیعی هستند، دقت کنید که بسته به رنج واقعی تراکنش ها میتوان تمام ضرایب مساله را به نحوی نرمالایز کرد که بعد از نرمالایز کردن اندازه تراکنش ها اعداد طبیعی باشد؛ پس این فرض به هیچ وجه محدود کننده نیست.\\
2) میتوان روی آرگومان های تابع مینیمایز معادله  \رجوع{eq:dynamic_prog_costoff} کران هایی پیدا کرد که تعداد سرچ های لازم را کاهش دهد. اگر 
$F_r^*$
و
$F_{\ell}^*$
آرگومان های تابع کمینه کردن معادله \رجوع{eq:dynamic_prog_costoff} باشند، برای دنباله تراکنش مشخص
$X_t=\{x_1,x_2,\dots,x_t\}$
میتوان نوشت:
\begin{equation}\label{eq:FlFr_bound}
F_{\ell}^* + F_r^* \leq \sum_{i \in [1,t]} |x_i| 
\end{equation}
در معادله \رجوع{eq:FlFr_bound} 
$|x_i|$
نمایانگر اندازه تراکنش فارغ از جهت آن است. پیام اصلی معادله \رجوع{eq:FlFr_bound} این است که \off حتی اگر بخواهد همه تراکنش ها را بپذیرد و هیچ گاه متعادل کردن برون بلاکچینی انجام ندهد و به تراکنش هایی که از سمت مقابل می آیند هم برای پذیرش تراکنش های یک سمت وابسته نباشد، در لحظه $1$  در سمت چپ کانال به اندازه مجموع تمام تراکنش های از چپ به راست و در سمت راست کانال به اندازه مجموع تمام تراکنش های از راست به چپ پول میگذارد، گذاشتن پولی بیشتر از این در کانال فقط باعث افزایش هزینه بی جهت میشود.
\شروع{قضیه}
اگر برای دنباله
$X_t$
که اندازه تراکنش های آن اعداد طبیعی هستند تعریف کنیم:
\begin{equation}
S \coloneq \sum_{i \in [1,t]} |x_i|
\end{equation}
آن گاه پیچیدگی محاسباتی پیدا کردن \off به روش \کد{dynamic programming} برای این دنباله
$\mathcal{O}(S^3t)$
است.
\پایان{قضیه}
\شروع{اثبات}
با شروع از 
$i =1$
و افزودن یک به یک به
$i$
،میتوان جدولی از کل مقادیر 
$\textsc{Cost}_{i}^{rej+reb}(F_{\ell},F_{r})$
برای تمام 

$F_{\ell},F_{r} \in [1,S]^2$
 و تمام زمان های
$i \leq t$
ساخت و هزینه محاسباتی این عمل
$\mathcal{O}(S^2t)$
است.

طبق معادله  \رجوع{eq:dynamic_prog_costoff}، \off باید برای $S$ مقدار مختلف 
$F_{\ell}+F_{r}$
مراحل زیر را طی کند:\\
\off باید 
برای هر
$i \leq t$
هربار تابع
$\textsc{Cost}_{i}^{rej+reb}(.,.)$
را با حداکثر
$S^2$
آرگومان مختلف فراخوانی کند و مقادیر آن ها را با هم مقایسه کند. در هر گام زمانی هزینه محاسباتی \off حداکثر 
$S^2$
است و در مجموع 
$t$
گام وجود دارد و \off باید این کار را برای 
$S$ مقدار مختلف 
$F_{\ell}+F_{r}$
تکرار کند پس در مجموع هزینه نهایی \off
$\mathcal{O}(S^3t)$
است. 
\پایان{اثبات}

در انتها لازم به ذکر است که استفاده از  \کد{dynamic programming} برای پیدا کردن \off یک مزیت اصلی دارد و آن این است که در حین پیدا کردن جواب بهنیه برای هر دنباله از تراکنش ها، جواب بهینه زیردنباله های آن هم به دست می آید و در نتیجه در پیاده سازی ها میتوانیم به راحتی اوراکلی را که الگوریتم \رجوع{Algorithm:logC-competitive-main} به آن نیاز دارد فراهم کنیم.

\قسمت{مقایسه هزینه الگوریتم \on و \off}
الگوریتم \off را به روش توصیف شده در قسمت \رجوع{قسمت:پیدا کردن الگوریتم آف} پیاده سازی کرده ایم و الگوریتم \on را هم طبق الگوریتم \رجوع{Algorithm:logC-competitive-main} و با کمک از \off به عنوان اوراکل، پیاده سازی کرده ایم. 
برای مقایسه هزینه این الگوریتم ها، 50 دنباله تراکنش هر کدام از طول 50 را به طور تصادفی تولید کرده ایم. تراکنش ها را به صورت مستقل از توزیع  گاوسی با میانگین 0 و انحراف معیار 3 نمونه برداری کرده  و سپس آن ها را به نزدیک ترین عدد صحیح گرد کرده ایم زیرا همانطور که در قسمت \رجوع{قسمت:پیدا کردن الگوریتم آف} توضیح دادیم برای پیدا کردن \off به روش  \کد{dynamic programming}، اندازه تراکنش ها باید گسسته باشد.
آزمایش را به ازای مقادیر مختلف پارامتر های تابع هزینه که در زیر آمده است تکرار کرده ایم:
$$R=0,f_1=3,f_2 \in \{0.5,2\} , C \in \{2,8\}$$
برای مقایسه \on و  \off
، 5 
متغیر زیر را در هر آزمایش محاسبه کرده و در نهایت روی کل 50 دنباله میانگین گرفته ایم:
\شروع{شمارش}
\فقره هزینه کل (مجموع هزینه های رد کردن + هزینه های شارژ کردن درون بلاکچینی + هزینه های متعادل کردن برون بلاکچینی)
\فقره مجموع کل پول کانال در انتهای پردازش تراکنش ها که در جدول با
$A(X)$
نمایش داده شده است.

\فقره نسبت تعداد تراکنش های پذیرفته شده به کل
\فقره میزان کل پول جابجا شده در کانال با متعادل کردن برون بلاکچینی
\فقره تعداد کل شارژ کردن های برون بلاکچینی انجام شده
\پایان{شمارش}

جدول \رجوع{جدول:مقایسه هزینه های آف و آن} خلاصه ای از نتایج این آزمایش را نشان میدهد. همانطور که در جدول مشاهده میشود، نسبت هزینه \on به \off در عمل بسیار کمتر از کران بالای اثبات شده در فصل \رجوع{فصل:نتایج تئوری} است. 

\paragraph{ طراحی روش های ابتکاری برای بهبود هزینه \on}\footnote{Heuristics}
جدول \رجوع{جدول:مقایسه هزینه های آف و آن} نشان میدهد که میزان پولی که \on به کانال اضافه میکند بسیار بسیار بیشتر از \off است و علاوه بر آن مشاهده میکنیم که با افزایش $C$  در یک رنج متوسط، هزینه \off تغییر چندانی نمیکند اما هزینه \on بسیار سریع رشد میکند. البته این نتیجه قابل انتظار است زیرا \on الگوریتم 
\کد{
$(4 +2 \slog, f_1)$-recharging
}
را دنبال میکند پس با افزایش $C$، پولی که در هر شارژ کردن به کانال اضافه میکند بیشتر میشود اما متاسفانه بخش زیادی از این پول عملا مورد استفاده قرار نمیگیرد زیرا همانطور که در جدول میبینید نرخ پذیرش \on نه تنها از \off بیشتر نیست بلکه کم تر هم هست.
 دلیل آن هم این است که \on از \bucket استفاده میکند تا بودجه تراکنش هایی در رنج های مختلف را جدا از هم قرار دهد. این امر سبب میشود که حتی اگر تراکنش های زیادی هم در محدوده یک \bucket خاص قرار نگیرند، باز هم \on برای آن تراکنش ها همیشه مقداری پول ذخیره کند و هیچ گاه از این پول برای پذیرش تراکنش های در رنج های دیگر استفاده نکند؛ حتی اگر تعداد آن تراکنش ها بسیار زیاد باشد.
دلیل این خاصیت های \on این است که این الگوریتم برای بدترین دنباله های موجود طراحی شده پس الگوریتم بدبینی است که با زیادی شارژ کردن کانال و با اطمینان حاصل کردن از اینکه برای هر رنجی از تراکنش مقدار از پیش تعیین شده ای بودجه دارد، میخواد تضمین کند که هزینه اش هیچگاه از حد خاصی بالاتر نمیرود. اما میتوان \on را تغییرات اندکی داد به نحوی که کم تر محتاطانه عمل کند و عملکرد آن را برای دنباله تراکنش های خوش رفتار (مثلا نمونه گیری شده از توزیع گاوسی) بهبود داد.
برای این منظور دو روش ابتکاری با الهام از \on طراحی میکنیم که کمتر از \on کانال را شارژ میکنند و کم تر بدبینانه عمل میکنند.
اولین روش ابتکاری مان را \oni مینامیم. \oni
زیر الگوریتم
\کد{
$(\slog, f_1)$-recharging
}
را دنبال میکند و بر خلاف \on سبد بودجه های مختلف ندارد.
\oni تمام تراکنش های کمتر مساوی
$\tracker$
را میپذیرد و هرگاه پول کافی برای تراکنشی نداشت به روش زیر عمل میکند: اگر اندازه تراکنش کمتر مساوی
$\frac{\tracker}{C}$
بود، متعادل کردن کانال انجام میدهد طوری که نصف کل پول در یک سمت کانال و نصف دیگر در سمت دیگر قرار گیرد و تراکنش را میپذیرد؛ اما اگر اندازه تراکنش از 
$\frac{\tracker}{C}$
بزرگ تر بود آن گاه \oni آن را رد میکند.

همانطور که در جدول  \رجوع{جدول:مقایسه هزینه های آف و آن}  میبینید هزینه \oni بسیار کمتر از \on و بسیار نزدیک به \off  است ولی در عوض نرخ پذیرش آن کم تر است. دلیل آن هم بدیهتا به خاطر ضریب کمتر شارژ کردن کانال
$(\slog)$
و همچنین به این دلیل است که \oni   
\bucket های مجزا برای تراکنش های مختلف ندارد و ممکن است تعداد زیادی از تراکنش های بزرگ 
$(x > \frac{\tracker}{C})$
را رد کند.

با مراجعه به جدول \رجوع{جدول:مقایسه هزینه های آف و آن}  یک مشکل مشترک بین \on  و \oni میبینیم، هر دو این الگوریتم ها برای حالت 
$f_2=2$
کانال را به طور متوسط بیشتر از 5 بار شارژ میکنند و چون هر بار شارژ کردن هزینه
$f_1$
را دارد این عمل باعث افزایش بسیار زیاد هزینه شده. دلیل این تعداد شارژ کردن زیاد هم این است که هر دو این الگوریتم ها به محضی که
$\tracker < A(X_t)$
میشود عمل شارژ کردن را انجام میدهند.

روش ابتکاری \onii را معرفی میکنیم که دقیقا عین \oni عمل میکند جز اینکه کانال را هنگامی شارژ میکند که
$\tracker < \alpha A(X_t)$
برای یک $\alpha$ دلخواه بزرگ تر از 1. دقت کنید که اگر قرار دهیم 
$\alpha =1$
آن گاه \onii دقیقا عین \oni خواهد بود. برای آزمایش های نشان داده شده در جدول \رجوع{جدول:مقایسه هزینه های آف و آن}  از 
$\alpha =2$
استفاده کرده ایم که همانطور که میتوان دید، این امر باعث شده که تعداد شارژ کردن های \onii نسبت به \oni برای حالت
$f_2=2$
تا بیشتر از نصف کاهش یابد و همچنین هزینه کلی \onii 
از هر دو \on و \oni کم تر است.

نکته ای که برای انتخاب
$\alpha$
باید مورد توجه قرار گیرد این است که اگر 
$f_1 >> f_2$
آن گاه شارژ کردن کانال به مراتب پر هزینه تر از رد کردن تراکنش هاست پس باید ترجیحا
$\alpha$
بزرگ تر انتخاب شود اما اگر 
$f_1 \sim f_2$
آن گاه بهتر است 
$\alpha$
های نزدیک به 1 انتخاب شود زیرا با یکبار شارژ کردن کانال میتوان تعداد زیادی تراکنش را پذیرفت و از پرداختن 
$f_2$
برای تعداد زیادی تراکنش جلوگیری کرد.\\


\input{chapters/tables/on-off-cost-comparision.tex}

\paragraph{مشاهده تغییر هزینه الگوریتم ها با تغییر توزیع تراکنش ها}
میتوان حدس زد که دنباله تراکنشی که در بخش قبل برای آزمایش هایمان استفاده کردیم دنباله خوش رفتاری است و باعث ایجاد هزینه های بسیار بالا نمیشود. دلیل این امر این است که اولا جهت تراکنش ها تقارن داشت پس انتظار داشتیم تراکنش هایی که از راست به چپ می آیند تقریبا برابر تراکنش هایی باشند که از چپ به راست می آیند و با اندکی شارژ کردن کانال بتوان تراکنش های زیادی را پذیرفت. ثانیا انحراف معیار توزیع گاوسی ای که تراکنش ها را از آن نمونه برداری کرده بودیم 3 بود که عدد نسبتا کمی است و این باعث میشد تراکنش ها در رنج اندازه هم و نسبتا کوچک باشند.
در این بخش انحراف معیار توزیع گاوسی را از 3 تا 20 افزایش میدهیم و نمودار تغییر هزینه الگوریتم های مختلف را در تصویر \رجوع{شکل:تغییر هزینه ها با افزایش انحراف معیار} نمایش میدهیم. 
همانطور که در شکل مشخص است هزینه تمام الگوریتم ها با افزایش انحراف معیار افزایش میابد و این امر دو دلیل دارد. اولا با زیاد شدن انحراف معیار اندازه تراکنش ها دور تر از هم میشود و احتمال اینکه تراکنش هایی با اندازه مشابه از دو سمت بیاید و باعث خنثی کردن پول لازم شود کم تر میشود، ثانیا با افزایش انحراف معیار تراکنش های بزرگ تر بیشتری ارسال میشود که یا نرخ رد کردن را بالا میبرد یا باعث شارژ بیشتر کانال میشود.

\شروع{شکل}[!htb]
\centerimg{plot-std-1}{11cm}
\شرح{تغییر هزینه الگوریتم ها با افزایش انحراف معیار توزیع تراکنش ها}
\برچسب{شکل:تغییر هزینه ها با افزایش انحراف معیار}
\پایان{شکل}

\شروع{شکل}[!htb]
\centerimg{plot-p}{11cm}
\شرح{تغییر هزینه الگوریتم ها با تغییر قرینگی دنباله ها}
\برچسب{شکل:تغییر هزینه ها با تغییر قرینگی}
\پایان{شکل}

نکته ای که در شکل \رجوع{شکل:تغییر هزینه ها با افزایش انحراف معیار}  باید به آن دقت کرد این است که هزینه الگوریتم \on همواره از کران بالای تئوری آن فاصله بسیار زیادی دارد و این تاییدی بر درستی ضریب رقابتی است.

برای از بین بردن قرینگی دنباله تراکنش ها این بار 50 دنباله هر کدام شامل 50 تراکنش را تحت شرایط زیر تولید میکنیم: اندازه هر تراکنش از یک توزیع \کد{folded normal} نمونه گیری شده که توزیع گاوسی متناظر آن میانگین صفر و انحراف معیار 3 دارد. سپس جهت تراکنش ها توسط یک توزیع برنولی با پارامتر $p$ تعیین شده است. 1 شدن متغیر برنولی نشان دهنده این است که تراکنش از چپ به راست است و در غیر این صورت از راست به چپ است. میانگین هزینه تمام الگوریتم ها به اضافه کران بالای تئوری هزینه الگوریتم \on را در تصویر \رجوع{شکل:تغییر هزینه ها با تغییر قرینگی} رسم کرده ایم.
همانطور که انتظار داشتیم با نزدیک تر شدن $p$  به 
$\frac12$
که به معنی متقارن تر شدن دنباله است، هزینه همه الگوریتم ها کمتر میشود. همچنین مجددا میتوان مشاهده کرد که هزینه \on از کران بالای تئوری آن فاصله ی قابل توجهی دارد. 

در هر دو تصویر \رجوع{شکل:تغییر هزینه ها با افزایش انحراف معیار} و \رجوع{شکل:تغییر هزینه ها با تغییر قرینگی} پارامتر های توابع هزینه به شرح زیر هستند:
$$f_1 = 3 , f_2 = 2 , R = 0 , C = 4 , \alpha=2$$




\قسمت{بررسی پارامتر های توابع هزینه برای \کد{Lightning Network}}
با بررسی تعداد زیادی از کانال های  \کد{Lightning Network} متوجه شدیم که 
$f_1$
که همان هزینه ثابت ایجاد کانال است حدود 1000 ساتوشی
\footnote{\lr{1 Satoshi is 0.00000001 BTC.}}
 است و بسیار بیشتر از 
$f_2$
است که برای تعداد بسیار زیادی از کانال ها حدود 1 ساتوشی است
~\cite{1ml,lngossip}.
با توجه به اینکه
$f_1 >> f_2$
میتوان نتیجه گرفت که الگوریتم \on در مورد  \کد{Lightning Network} به صورت زیر عمل میکند:  تا زمانی که تعداد تراکنش های دنباله تراکنش از حد مشخصی کم تر است، \on کانالی ایجاد نمیکند که در دنیای واقعی به این معنی است که الگوریتم به کاربران توصیه میکند که تراکنش هایشان را از طرق دیگر انجام دهند، هرچند این امر هزینه بر است اما هزینه آن همچنان کمتر از این است که باز کردن کانال به صرفه باشد. زمانی که دنباله تراکنش از حدی بزرگ تر شد یا در دنیای واقعی تعداد تراکنش های دو کاربر از حدی بالاتر رفت، الگوریتم توصیه به باز کردن کانال میکند.

\paragraph{پیدا کردن $C$
 به طور تجربی در  \کد{Lightning Network}}
از آنجاییکه 
$C$
نقش اساسی ای در ضریب رقابتی الگوریتم \on دارد، بر آن شدیم تا مقدار آن در  \کد{Lightning Network} را به طور تجربی پیدا کنیم. برای این کار از یکی از بروز ترین اسنپ شات\footnote{snapshot}
های این شبکه که مربوط به سپتامبر سال 2021 است استفاده کردیم~\cite{lngossip}.
در این اسنپ شات در مجموع $117,894$ کانال وجود دارد که بعد از یکجا در نظر گرفتن کانال های کاربرانی که بیش از یک کانال دارند
$63,820$
کانال باقی ماند. برای هر یک از این کانال ها طول کوتاه ترین دور در گراف را که شامل کانال است، پیدا کردیم و آن را در جدول \رجوع{جدول:پیدا کردن طول حلقه} منعکس کرده ایم.
حدود  $9.5$ درصد کانال ها در هیچ دوری حضور ندارند و در نتیجه برای این کاربران اصولا متعادل کردن برون بلاکچینی امکان پذیر نیست.
اما تعداد بسیار زیادی از کانال های شبکه عضو دوری به طول 4 یا 5 هستند.\\



\begin{table}[htb!]
\begin{latin}
\centering
\resizebox{\textwidth}{!}{%
  \begin{tabular}{|c||c|c|c|c|c|} 
 \hline
 \textbf{Cycle length} & $\leq 4$  & $5$ & $6$ & $7$ & N.A. \\
 \hline
 %\textbf{Frequency} & $21,421$ & $2,855$ & $117$ & $10$ & $2,777$\\ 
 \textbf{Frequency} &  $49,424 (77.44\%)$ & $7,758 (12.16\%)$ & $469 (0.73\%)$ & $12 (0.02\%)$ & $6,157 (9.65\%)$\\
 \hline 
\end{tabular}}
\end{latin}
\شرح{طول کوتاه ترین دوری که هر کانال شبکه \کد{Lightning Network} عضوی از آن است. }
\برچسب{جدول:پیدا کردن طول حلقه}
\end{table}

اما نکته بسیار مهمی که باید به آن توجه کرد این است که موجودی طرفین کانال در  \کد{Lightning Network} یک داده ی خصوصی است و نمیتوان به آن دست یافت. هرچند مجموع پول طرفین کانال را میتوان با مراجعه به بلاکچین پیدا کرد اما اینکه این پول چگونه به دو طرف تخصیص یافته یک داده ی خصوصی است. در نتیجه ما اطلاعاتی از موجودی کاربران در دور هایی که در  \کد{Lightning Network} پیدا کرده ایم نداریم و برخی از این دور ها ممکن است فاقد پول کافی برای انجام متعادل کردن برون بلاکچینی باشند.






