
\فصل{مدلسازی مسئله} در این قسمت مدلسازی مساله به همراه مدل هزینه برای کانال دو طرفه را بررسی میکنیم. یعنی کانالی که در آن هر دو طرف کانال میتوانند برای هم تراکنش بفرستند. در زیر مساله های اول و دوم مدل هزینه ای تفاوت اندکی با مدل مطرح شده در این بخش دارد که در بخش \رجوع{} این تفاوت را توضیح میدهیم.

\قسمت{کانال پرداخت} ما شبکه کانال های پرداخت را با یک گراف غیر جهت دار 
$G=(V,E)$
نمایش میدهیم که در آن راس ها کاربران و یال ها کانال های پرداخت هستند. به طور مثال کانال پرداخت بین دو کاربر 
$\ell , r \in V$
یک یال در گراف است
$(\ell , r) \in E$.
ما در این پایان نامه فقط روی یک زوج کاربر
$\ell , r$
و کانال بینشان تمرکز میکنیم. پولی که 
$\ell$ و $r$
در این کانال دارند به ترتیب با 
$b(\ell)$ و $b(r)$
\پاورقی{balance}
نمایش داده میشود و مجموع پولی که در کانال وجود دارد 
$b(\ell)+b(r)$
را ظرفیت کانال مینامیم. ظرفیت کانال از زمان باز شدن تا بسته نشدن کانال ثابت باقی میماند اما سهم هر کس از ظرفیت کانال یعنی همان
$b(\ell)$ و $b(r)$
با ارسال تراکنش تغییر میکند.



\قسمت{تراکنش ها}\برچسب{قسمت:تراکنش ها}
 در این پایان نامه قصد داریم مدیریت تراکنش های برون بلاکچینی کانال 
$(\ell , r)$
را مدیریت کنیم بنابراین همیشه منظور از تراکنش تراکنش برون بلاکچینی است مگر اینکه صریحتا خلاف آن را ذکر کنیم. دنباله تراکنش 
$X_t=(x_1,x_2,\dots,x_t), x_i \in \mathbb{R}$
را در نظر بگیرید که تمام تراکنش های رسیده شده به کانال 
$(\ell , r)$
 از لحظه 1 تا $t$  را نشان میدهد. تراکنش ها به ترتیب زمان سر میرسند. هر تراکنش با یک عدد حقیقی مثبت و یک جهت (یا معادلا یک علامت) نمایش داده میشود که عدد حقیقی بیانگر اندازه تراکنش است (مثلا 1 بیتکوین ،$0.05$ بیتکوین و ...) و جهت نشان دهنده این است که تراکنش از 
$\ell$ به $r$
است یا از 
$r$ به $\ell$. 
مثلا
$\ltr{x}$ (یا $x > 0$)
نمایانگر تراکنشی است که از 
$\ell$ به $r$
میرود. در این پایان نامه از اول حروف \کد{left} و \کد{right} یعنی $\ell$ و $r$ استفاده میکنیم تا جهت راست به چپ یا چپ به راست تراکنش ها هم معنی بصری شهودی تری داشته باشد.

وقتی میگوییم تراکنشی در جهت
$\ell$ به $r$
است دو حالت وجود دارد:
\begin{شمارش}
\فقره یا خود 
$\ell$ 
میخواهد برای 
$r$
پول بفرستد و این تراکنش را ایجاد کرده.
\فقره یا یکی از همسایه های $\ell$  میخواهد پولی را به $r$ یا یکی از همسایه های $r$ برساند و در این تراکنش 
$(\ell , r)$
نقش واسطه را دارد.
\end{شمارش}

در هر دو این حالت ها ما تراکنش را به صورت(یا معادلا $x > 0$) $\ltr{x}$ نمایش میدهیم و برعکس تراکنش از
$r$ به $\ell$
را با 
$\rtl{x}$ (یا معادلا $x < 0$)
نمایش میدهیم.

وقتی یک تراکنش جدید فرا میرسد 
$\ell , r$ 
میتوانند تصمیم بگیرند آن را انجام دهند یا خیر. همانطور که در بخش \رجوع{قسمت:تراکنش های کانال پرداخت} توضیح دادیم، امضا و تایید هر دو عضو یک کانال برای انجام شدن یک تراکنش لازم است پس 
$\ell$ و $r$
باید هر دو تایید کنند تا تراکنش انجام شود. دنباله
$X_t=(x_1,x_2,\dots,x_t)$
دنباله ی تمام تراکنش های درخواست شده به 
$(\ell , r)$
را نمایش میدهد فارغ از اینکه این تراکنش ها توسط 
$r$ و $\ell$
پذیرفته میشوند یا رد میشوند. 
$r$ و $\ell$
تنها زمانی میتوانند تراکنش $\ltr{x}$ را بپذیرند که
$b(\ell) \geq x$
باشد و بعد از پذیرش تراکنش توزیع پول ها در کانال به صورت زیر تغییر میکند:
$$b(\ell) \leftarrow b(\ell) - x  , b(r) \leftarrow b(r) + x $$
و برای تراکنش $\rtl{x}$ همه چیز دقیقا برعکس است یعنی برای پذیرش این تراکنش باید 
$b(r) \geq x$
باشد و پس از پذیرش این تراکنش، توزیع پول ها به صورت زیر تغییر میکند:
$$b(\ell) \leftarrow b(\ell) + x  , b(r) \leftarrow b(r) - x $$

$r$ و $\ell$
ممکن است به دلایل متعدد تصمیم بگیرند تراکنشی را رد کنند مثلا ممکن است پول کافی برای انجام تراکنش نداشته باشند و یا اینکه تراکنش به حدی بزرگ باشد که در صورت انجام آن موجودی یک طرف کانال صفر یا بسیار کم شود و طرفین تصمیم بگیرند که پذیرش این تراکنش با توجه به موجودی فعلی در کانال معقول نیست.
رد کردن تراکنش دو معنی میتواند اینجا داشته باشد. مثلا تراکنش
$\ltr{x}$
را در نظر بگیرید. همانطور که پیش از این گفتیم یا این تراکنش را خود
$\ell$
ایجاد کرده یا تراکنش یکی از همسایه های 
$\ell$
است که از او خواسته این تراکنش را انتقال دهد.

\begin{شمارش}
\فقره اگر تراکنش توسط خود 
$\ell$
ایجاد شده باشد ولی 
$r$ و $\ell$
آن را انجام ندهند معنای آن در دنیای واقعی این است که 
$\ell$ 
باید پولی برای 
$r$ 
 بفرستد ولی به دلیل عدم توافق، نمیتواند این پول را به صورت مجانی در کانال پرداخت اش با 
$r$ 
بفرستد و نیاز دارد این تراکنش را از طریق یک پلتفرم دیگر مثلا بانک یا تراکنش های درون بلاکچینی روی بلاکچین بفرستد، پس این امر هزینه ای را متحمل $\ell$  خواهد کرد چون انجام تراکنش روی هر پلتفرمی مثل بانک یا بلاکچین یک کارمزد دارد.

\فقره اگر تراکنش برای یکی از همسایگان $\ell$ باشد و 
$r$ و $\ell$
تصمیم بگیرند آن را انتقال ندهند، از کارمزد آن تراکنش دارند صرف نظر میکنند چون همانطور که قبلا گفتیم واسطه ها در شبکه کانال های پرداخت برای انتقال تراکنش ها کارمزد میگیرند. این چشم پوشی از کارمزد را هم میتوان با یک هزینه مدل کرد.
\end{شمارش}

پس در هر دو حالت بالا عدم انجام تراکنش در کانال برای  $\ell$ و $r$  هزینه ای در بردارد. برای رد کردن تراکنش به اندازه $x$ هزینه خطی 
$Rx+f_2$
را در نظر میگیریم.  
$R , f_2 \in \mathbb{R}^+$
اعداد ثابت هستند که در در قسمت \رجوع{}  توضیح میدهیم که چگونه باید انتخاب شوند. 

\textcolor{red}{\textbf{نکته مهم:}}
دقت کنید که در مدل هزینه ای مطرح شده در این قسمت که مدل هزینه ای کانال دو طرفه است فرض را بر این میگیریم که طرفین کانال با هم همکاری دارند و میخواهند مجموع هزینه هایشان را به کمک هم کمینه کنند.


\قسمت{شارژ کردن کانال روی بلاکچین}\پاورقی{on-chain recharging}\برچسب{قسمت:شارژ کردن کانال روی بلاکچین} 
گاهی انجام تراکنش های متعدد از یک جهت کانال باعث میشود تمام پول کانال دست یک نفر باشد و دیگری پولش صفر شود. مثلا اگر پول $\ell$ صفر شده باشد تا زمانی که تراکنشی از سمت $r$ نیاید، $\ell$ نمیتواند هیچ تراکنشی بفرستد و این امر مطلوب نیست به همین دلیل گاهی طرفین تصمیم میگیرند این کانالی که به اصطلاح نامتعادل \پاورقی{depleted channel} شده است را روی بلاکچین ببندند و کانال جدیدی باز کنند. این کار را شارژ کردن درون بلاکچینی مینامیم.
همانطور که میدانیم برای بستن یک کانال پرداخت باید $\ell$ و $r$ یک تراکنش روی بلاکچین بفرستند همچنین برای باز کردن کانال پرداخت جدید هم باید یک تراکنش دیگر بسازند. پس شارژ کردن درون بلاکچینی هزینه ای را متحمل $\ell$ و $r$  میکند که ما این هزینه را با 
$f_1 \in \mathbb{R}^+$
نشان میدهیم. اما شارژ کردن درون بلاکچینی یک هزینه ضمنی دیگر هم دارد. وقتی دو کاربر $\ell$ و $r$ یک کانال پرداخت ایجاد میکنند و در مجموع مقدار $F$ بیتکوین در آن ذخیره میکنند، این بیتکوین ها تا پیش از بسته شدن کانال از درسترس $\ell$ و $r$ خارج میشوند. اگر این پول در کانال قفل نشده بود $\ell$ و $r$ میتوانستند آن را سرمایه گذاری کنند و با نرخ بهره ای سود به دست آورند اما حالا که در کانال ذخیره شده این سود را از دست میدهند. این فرصت سرمایه گذاری را که با باز کردن کانال جدید از بین میرود را به صورت یک هزینه در نظر میگیریم و آن را با 
$\beta F$
نشان میدهیم. $F$ پول قفل شده در کانال است و $\beta$ عددی بین 0 و 1 است که میزان سوددهی سرمایه گذاری در جهان خارج را نشان میدهد. هر چه $\beta$ بزرگ تر باشد، ذخیره کردن پول در کانال پرداخت به جای سرمایه گذاری کردن ضرر بیشتری برای  $\ell$ و $r$  دارد و بالطبع هزینه بیشتری هم میپردازند. 

پس در مجموع هزینه شارژ کردن درون بلاکچینی و باز کردن یک کانال جدید با ظرفیت $F$ برابر 
$\beta F + f_1$
است که در آن
$f_1 \in \mathbb{R}^+$
نماینده کارمزد بستن یک کانال و باز کردن کانال جدید بر بلاکچین است. 
$F$
مجموع پولی است که $\ell$ و $r$ در کانال قرار میدهند و
$\beta \in [0,1]$
نماینده میزان سوددهی یک واحد پول با سرمایه گذاری در دنیای خارج از شبکه کانال های پرداخت است.

\قسمت{متعادل کردن کانال روی شبکه کانال های پرداخت}\پاورقی{off-chain rebalancing} \برچسب{قسمت:متعادل کردن کانال روی شبکه کانال های پرداخت} همانطور که پیش از این هم مطرح شد هزینه شارژ کردن کانال روی بلاکچین بسیار بالا است بنابراین در عمل بسیار کم از این روش استفاده میشود. در واقعیت معروف ترین نسخه های کاربری \کد{Lightning Network} بدون استفاده از بلاکچین و بر روی خود شبکه کانال های پرداخت کانال خود را متعادل میکنند. اما چگونه؟ با یک مثال توضیح میدهیم. به حلقه سمت چپ شکل \رجوع{شکل:متعادل کردن کانال روی شبکه کانال های پرداخت} توجه کنید. میبینید که $\ell$ در کانال
$(\ell , r)$
پولی ندارد اما در کانال با $h$ مقدار 15 واحد پول دارد. $\ell$ میخواهد بدون اینکه مجبور شود کانالش با $r$ را ببندد، به موجودیش در کانال 
$(\ell , r)$
بیفزاید؛ $\ell$ یک تراکنش حلقه ای ایجاد میکند که با واسطه $h$ برای خودش $5$ واحد پول از کانال 
$(\ell , h)$
به کانال
$(\ell , r)$
بریزد. فلش های بنفش رنگ مسیر تراکنش را نشان میدهند. در واقع فرستنده و گیرنده این تراکنش خود $\ell$ است. 

\شروع{شکل}[hb]
\centerimg{off-chain-rebalancing-new}{10cm}
\شرح{مثالی از متعادل کردن کانال روی شبکه کانال های پرداخت}
\برچسب{شکل:متعادل کردن کانال روی شبکه کانال های پرداخت}
\پایان{شکل}

پس متعادل کردن کانال روی شبکه کانال های پرداخت چیزی نیست جز تراکنشی در یک دور. در این تراکنش با واسطه هم مانند هر تراکنش با واسطه دیگری $h$ که واسطه است از
$\ell , r$
کارمزد دریافت میکند. در قسمت \رجوع{قسمت:تراکنش ها} توضیح دادیم که کارمزدی که یک واسطه برای جابجایی یک تراکنش به ارزش $x$ میگیرد یک تابع خطی از $x$ به صورت
$Rx+f_2$
است. پس متعادل کردن روی شبکه کانال های پرداخت در حلقه ای که $C$ واسطه دارد
$C(Rx+f_2)$
است. مثلا در شکل \برچسب{شکل:متعادل کردن کانال روی شبکه کانال های پرداخت} فقط یک واسطه وجود دارد، $h$، پس
$C=1$
است.






\قسمت{تعریف الگوریتم بهینه آفلاین و الگوریتم آنلاین}\برچسب{تعریف الگوریتم بهینه آفلاین و الگوریتم آنلاین}
الگوریتم بهینه آفلاین که آن را با $\off$ نمایش میدهیم، یک دنباله تراکنش $X_t=(x_1,x_2,\dots,x_t), x_i \in \mathbb{R}^+$ به عنوان ورودی میگیرد و به عنوان خروجی سه دنباله $Reb_t$ و  $Y_t$ و $Rech_t$ را تحویل میدهد. 

$$Rech_t=\{rech_1,rech_2,\dots,rech_t\}, rech_i \in  \{\mathbb{R}^{\geq 0}\} \times \{\mathbb{R}^{\geq 0}\}$$
$$Reb_t=\{reb_1,reb_2,\dots,reb_t\}, reb_i \in  \mathbb{R}$$
$$Y_t=\{y_1,y_2,\dots,y_t\}, y_i \in \{\texttt{Accept},\texttt{Reject}\}$$


دنباله $Rech_t$ نشان دهنده این است که در چه زمان هایی الگوریتم  \off شارژ کردن درون بلاکچینی انجام داده است. هر عضو دنباله $Rech_t$ یک زوج مرتب است 
$rech_i = (rech^{\ell}_i,rech^{r}_i)$
که نشان دهنده میزان پول اضافه شده به $\ell$ و $r$ هستند.

 دو متغیر جدید
 $A_{\ell}(X_i)$ و $A_{r}(X_i)$
را تعریف میکنیم که به ترتیب نشان دهنده متغیر های 
$b(\ell) , b(r)$
 پس از پردازش تراکنش $i$ توسط الگوریتم \off هستند.
در لحظه $i$ پس از انجام شارژ کردن درون بلاکچینی، موجودی طرفین کانال به صورت زیر تغییر میکند:

$$A_{\ell}(X_i) = A_{\ell}(X_{i-1}) + rech^{\ell}_i $$
$$A_{r}(X_i) = A_{r}(X_{i-1}) + rech^{r}_i $$
همچنین هزینه الگوریتم \off
به صورت زیر تغییر میکند:
\begin{equation}
\costoff(X_{i}) =
    \begin{cases}
      \costoff(X_{i-1}) & \text{If } \; rech^{\ell}_i = 0 \; \text{and} \; rech^{r}_i = 0  \\
      \costoff(X_{i-1}) + \beta(rech^{\ell}_i+rech^{r}_i) + f_1 & \text{If } \; rech^{\ell}_i > 0 \; \text{or} \; rech^{r}_i > 0  \\
    \end{cases}       
\end{equation}
متغیر $reb_i$ نشان دهنده اندازه و جهت متعادل کردن برون بلاکچینی است. عبارت زیر تغییر موجودی کاربران پس از متعادل کردن برون بلاکچینی در لحظه
$i$
 را نشان میدهد.
\begin{equation}
\costoff(X_{i}) =
    \begin{cases}
      A_{\ell}(X_i) =  A_{\ell}(X_i) - reb_i ,  A_{r}(X_i)=  A_{r}(X_i) + reb_i  & \text{If }\;\; 0<reb_i \leq A_{\ell}(X_i) \\
      A_{r}(X_i) =  A_{r}(X_i) - |reb_i| ,  A_{\ell}(X_i)=  A_{\ell}(X_i) + |reb_i|  & \text{If }\;\;  -A_{r}(X_i) \leq reb_i < 0 \\
    \end{cases}       
\end{equation}
دقت کنید که اگر در سمت چپ نیاز به پول باشد \off از راست به چپ 
($reb_i < 0$)
پول منتقل میکند و برعکس اگر در سمت راست نیاز به پول باشد \off از چپ به راست
($reb_i > 0$)
پول منتقل میکند و هیچ گاه از هر دو جهت همزمان پول منتقل نمیکند زیرا این کار فقط باعث افزایش هزینه نالازم میشود.
هزینه
\off
پس از انجام متعادل کردن برون بلاکچینی به صورت زیر تغییر میکند:
 \begin{equation}
\costoff(X_{i}) =
    \begin{cases}
      \costoff(X_{i-1}) & \text{If } \;\; reb_i = 0  \\
      \costoff(X_{i-1}) + C(R|reb_i| + f_2) & \text{If } \;\; reb_i \neq 0  \\
    \end{cases}       
\end{equation}


در نهایت متغیر $y_i$ نشان دهنده این است که آیا الگوریتم \off تراکنش $x_i$ را پذیرفته یا خیر. اعضای دنباله $Y_i$ باید در شرط زیر صدق کنند :

\begin{equation}
    \begin{cases}
      \text{If } \;\; x_i > 0 \; \text{then } \;\; y_i = \texttt{Accept} \;\; \text{ If only } \;\; A_{\ell}(X_{i-1}) > x_i \\
      \text{If } \;\; x_i < 0 \; \text{then } \;\; y_i = \texttt{Accept} \;\; \text{ If only } \;\; A_{r}(X_{i-1}) > |x_i| \\
    \end{cases}       
\end{equation}
شرط بالا به این معنی است که الگوریتم فقط زمانی میتواند تراکنشی را بپذیرد که پول کافی برای آن داشته باشد.  هزینه 
\off
پس از پذیرش یا رد هر تراکنش به صورت زیر تغییر میکند:

 \begin{equation}
\costoff(X_{i}) =
    \begin{cases}
      \costoff(X_{i-1}) & \text{If } \; y_i= \texttt{Accept}  \\
       \costoff(X_{i-1}) + R|x_i| + f_2 & \text{If } \; y_i= \texttt{Reject}  \\
    \end{cases}       
\end{equation}
دقت کنید که ممکن است در لحظه $i$, 
\off
یک کدام یا هر دو روش شارژ کردن و متعادل کردن را انجام دهد. در این صورت ترتیب آپدیت شدن موجودی کانال یعنی  $A_{\ell}(X_i)$ و $A_{r}(X_i)$ به ترتیبی که در بالا گفته شد انجام میشود، یعنی اول شارژ کردن درون بلاکچینی موجودی کانال را آپدیت میکند، بعد متعادل کردن برون بلاکچینی و در نهایت پذیرش تراکنش، همچنین هزینه \off به اندازه مجموع هزینه همه گام های انجام شده افزایش میابد.
 
نکته مهم دیگری که باید مورد توجه قرار گیرد این است که الگوریتم \off الگوریتمی با مینیمم هزینه است. یعنی اگر مجموعه
$\mathcal{ALG}$
مجموعه کل الگوریتم هایی باشد که با گرفتن دنباله ورودی $X_t$، سه دنباله معتبر خروجی $Reb_t$ و  $Y_t$ و $Rech_t$ را تحویل میدهند الگوریتم \off کمترین هزینه را بین تمام الگوریتم های 

$\mathcal{ALG}$
دارد. یعنی :
$$\costoff(X_i)= \min_{alg \in \mathcal{ALG}}{\costalg(X_i)} \quad \forall X_i$$

همانطور که در بخش \رجوع{قسمت:الگوریتم آنلاین} توضیح دادیم الگوریتم آفلاین به کل دنباله ورودی دسترسی دارد و بعد تصمیم گیری میکند. اما الگوریتم آنلاین که آن را با \on نمایش میدهیم، اعضای دنباله تراکنش ها را یک به یک میبیند و بعد از دیدن
$x_i$
پیش از دیدن سایر تراکنش ها باید درباره
$reb_i$ و  $y_i$ و $rech_i$
تصمیم گیری کند. 
هزینه الگوریتم آنلاین
$\coston(X_i)$
برای پردازش دنباله تراکنش 
$X_i$
 هم با هر تصمیم مشابه الگوریتم آفلاین آپدیت میشود. بدیهی است که همانطور که در مثال \کد{Ski-Rental} دیدیم هزینه الگوریتم آنلاین معمولا بیشتر از هزینه الگوریتم آفلاین است و ماکسیمم نسبت این دو هزینه را ضریب رقابتی نامیده و با $c$ نمایش میدهیم:

$$\coston(X_i) \leq c \cdot \costoff(X_i) \quad \forall X_i$$








\قسمت{مثالی از مسئله کانال های دو طرفه} در این قسمت خلاصه ای از گزینه های موجود برای مدیریت کانال پرداخت و هزینه آن ها ارائه میدهیم که مطالب این فصل را خلاصه و جمع بندی میکند.
$\ell , r$
یک کانال پرداخت دارند و در هر لحظه با تراکنشی به اندازه دلخواه و در جهت $\ell$ به $r$ یا $r$ به $\ell$ روبرو هستند.
$\ell , r$ 
باید مشترکا تصمیم بگیرند که کدام تراکنش ها را بپذیرند و کدام ها را رد کنند. رد کردن هر تراکنش به اندازه $x$ هزینه ای برابر 
$Rx+f_2$
دارد. برای پذیرش تراکنش به اندازه $x$، فرستنده تراکنش باید حداقل به اندازه $x$ در کانال پول داشته باشد. به شکل \رجوع{شکل:خلاصه کانال پرداخت دو طرفه} توجه کنید که در آن یک دنباله تراکنش های  
$\rtl{1},\rtl{9},\ltr{6},\ltr{2}$
به کانال پرداخت 
$(\ell,r)$
میرسد. پول اولیه هر دو کاربر 
$\ell$ و $r$
در کانال 4 است. با پذیرش تراکنش اول 1 واحد پول از $r$ به $\ell$ منتقل میشود که با سبز رنگ نمایش داده شده است.
تراکنش دوم
$\rtl{9}$
است و در این مثال 
$\ell$ و $r$ 
تصمیم میگیرند آن را رد کنند و هزینه 
$9R+f_1$
را متحمل شوند در نتیجه پول $\ell$ و $r$ پس از این تراکنش تغییری نمیکند.
 تراکنش سوم
$\ltr{6}$
 است و 
$\ell$ و $r$ 
میخواهند آن را بپذیرند اما مشکل این است که $\ell$ پول کافی در کانال برای پذیرش آن ندارد. پس 
$\ell$ و $r$ 
با همکاری هم کانال خود را ابتدا متعادل میکنند تا $\ell$ پول کافی داشته باشد. همانطور که در بخش \رجوع{قسمت:متعادل کردن کانال روی شبکه کانال های پرداخت} توضیح دادیم، در روش متعادل کردن کانال، $\ell$ برای خودش از یکی از کانال های دیگرش به کانال 
$\ell$ و $r$ 
پول میفرستد. در مثال شکل \رجوع{شکل:خلاصه کانال پرداخت دو طرفه} $\ell$ 2 واحد پول میریز. پس با انجام دادن "متعادل کردن کانال روی شبکه کانال های پرداخت" ابتدا 2 واحد پول از $r$ به $\ell$ منتقل میشود (2 بلوک آبی رنگ) و موجودی جدید $\ell$ 
7  و موجودی جدید $r$ 
1 میشود. در این پایان نامه برای سادگی فرض میکنیم که متعادل کردن کانال سریع انجام میشود پس $\ell$ میتواند پس از متعادل کردن کانال سریعا تراکنش 
$x_3$
را بپذیرد. با پذیرفتن این تراکنش 6 واحد پول (بلوک های سبز رنگ) از $\ell$ به $r$ منتقل میشود. در مجموع هزینه ای که $\ell$ و $r$ برای انجام این تراکنش متحمل شدند همان هزینه متعادل کردن کانال بود که برابر 
$C(2R+f_1)$
است و $C$ تعداد واسطه ها در حلقه متعادل کردن کانال است.
در نهایت تراکنش 
$\ltr{2}$
میرسد که مجددا 
$\ell$ و $r$  
قصد پذیرش آن را دارند ولی چون $\ell$ پول کافی برای پذیرش آن را ندارند مجبور اند مقداری پول تزریق کنند. در این مثال از روش شارژ کردن کانال روی بلاکچین استفاده میکنند یا به عبارتی این کانال را میبندند و کانال جدیدی باز میکنند که در آن موجودی $\ell$ 
3 واحد بیشتر است و موجودی $r$
1 واحد بیشتر از حالت فعلی است. این پول های اضافه شده با بلوک های صورتی رنگ نمایش داده شده اند. هزینه شارژ کردن کانال روی بلاکچین همانطور که در قسمت \رجوع{قسمت:شارژ کردن کانال روی بلاکچین} توضیح داده شد، برابر است با:
\کد{
$$\beta(F+f_1) , F = F_{\ell} + F_r$$
}
پس از شارژ کردن کانال موجودی $\ell$ برای پذیرش تراکنش $\ltr{2}$ کافی میشود.



\شروع{شکل}[hb]
\centerimg{bidirecModel-new}{15cm}
\شرح{خلاصه کانال پرداخت دو طرفه}
\برچسب{شکل:خلاصه کانال پرداخت دو طرفه}
\پایان{شکل}

