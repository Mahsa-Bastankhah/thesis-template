\فصل{نتایج تئوری}\برچسب{فصل:نتایج تئوری}
در این فصل ابتدا دو  زیرالگوریتم پرکاربرد که از آنها در طراحی الگوریتم اصلی مان استفاده میکنیم را معرفی میکنیم و سپس به سراغ توصیف و پیدا کردن ضریب رقابتی الگوریتم آنلاینمان برای حل مساله کانال دو طرفه میرویم.  


در تمام نتایج تئوری این پایان نامه فرض میکنیم که $\beta$ که در تابع هزینه شارژ کردن درون بلاکچینی کانال نقش داشت برابر $1$ است. این فرض به هیچ وجه محدود کننده نیست زیرا هدف ما در این پایان نامه پیدا کردن ضریب رقابتی است که نسبت بین هزینه \on و \off است. برای هر دنباله تراکنش $X_t$ میتوان نوشت:
$$ c  = \frac{\coston(X_t)}{\costoff(X_t)} =  \frac{\frac{\coston(X_t)}{\beta}}{\frac{\costoff(X_t)}{{\beta}}}$$
پس میتوان هر دو تابع هزینه را تقسیم بر $\beta$ کرد بدون اینکه ضریب رقابتی تغییر کند. در نتیجه تابع هزینه شارژ کردن درون بلاکچینی به صورت 
$F + \frac{f_1}{\beta}$
در می آید. سایر توابع هزینه هم به همین صورت تقسیم بر $\beta$ میشود. در این صورت باید یک نسخه جدید از تمام پارامتر های توابع هزینه مسئله ارائه دهیم:
$$f_1' \coloneq \frac{f_1}{\beta} , f_2' \coloneq \frac{f_2}{\beta} , R' \coloneq \frac{R}{\beta} $$.
از آنجا که ضریب رقابتی الگوریتم اصلی ما وابسته به هیچ کدام از پارامتر های بالا نیست، برای سادگی در تمام این پایان نامه از همان نام های $f_1,f_2,R$ استفاده میکنیم.

\قسمت{دو زیر الگوریتم پر کاربرد}

\paragraph{دنبال کردن موجودی الگوریتم $\off$}
الگوریتم بهینه آفلاین \off
 را در بخش \رجوع{تعریف الگوریتم بهینه آفلاین و الگوریتم آنلاین} معرفی کردیم. پیدا کردن \off در حالت کلی مساله کانال دو طرفه \کد{NP-hard} است اما مجموع پولی که الگوریتم \off پس از پردازش دنباله تراکنش $X_t$ در کانال دارد یعنی 
$A(X_t) \coloneq A_{\ell}(X_i) + A_{r}(X_i)$
را میتوان به صورت تقریبی با ضریب ثابت از مقدار واقعی محاسبه کرد، میتوانید به مقاله ~\cite{oracle} برای اطلاعات بیشتر درباره چگونگی محاسبه این تقریب مراجعه کنید.

در این پایان نامه، الگوریتم آنلاینی که طراحی میکنیم مبنی بر استفاده از تقریب $A(X_t) $ در هر لحظه است. یعنی به طور خاص فرض میکنیم اوراکلی\footnote{Oracle} وجود دارد که در هر لحظه $t$ میتوان تابع $\Call{Funds}{X_t}$ 
اراکل را فراخوانی کرد و خروجی  $A(X_t) $ را گرفت.

به طور خاص الگوریتم انلاینی که در این پایان نامه طراحی میکنیم پس از دیدن تراکنش $x_i$، پیش از هر تصمیمی ابتدا تابع
\کد{
 $ A(X_i) \leftarrow \Call{Funds}{\{x_1,x_2,\dots,x_i\}}$
}
فراخوانی میکند که خروجی  $A(X_i) $ را میدهد و بعد با داشتن این اطلاعات درباره اینکه آیا باید با انجام دادن شارژ کردن درون بلاکچینی به کانال پول اضافه کند یا نه تصمیم میگیرد.
این نحوه استفاده از اطلاعات تقریبی درباره الگوریتم \off در طراحی الگوریتم \on روش بسیار مرسومی است و بسیاری از کارهای پیشین هم روشی مشابه همین روش را پیش گرفته اند 
~\cite{}.
   






\paragraph{تصمیم گیری درباره شارژ کردن کانال روی بلاکچین با تقلید از الگوریتم \off}
الگوریتم 
\رجوع{Algorithm:onlinetracker}
چگونگی تصمیم گیری درباره شارژ کردن کانال توسط \on با داشتن دسترسی به تابع 
$\Call{Funds}{X_t}$ 
را نشان میدهد. این الگوریتم متغیری به نام 
$\tracker$
را ذخیره میکند. هر بار که تراکنش جدید فرا میرسد  \on
$\tracker$  
را با خروجی تابع
$\Call{Funds}{X_t}$
یعنی
 $A(X_t)$
مقایسه میکند. اگر $\tracker$  کوچک تر بود آن گاه \on پول موجود در کانال را افزایش میدهد طوری که مجموع پول کانال به
$\gamma(\Call{Funds}{X_t} + \delta)$
برسد. (درباره اینکه چه بخشی از این پول را به 
$\ell$
و چه بخشی را به 
$r$
اختصاص میدهد در بخش های بعدی صحبت میکنیم.
)
همچنین الگوریتم مقدار  $\tracker$ را به مقدار جدید
$\Call{Funds}{X_t} + \delta$
آپدیت میکند و دوباره همین روند را ادامه میدهد.
این الگوریتم را
\کد{
$(\delta,\gamma)$-recharging
}
مینامیم و در طراحی الگوریتم اصلی از آن استفاده میکنیم. 


دقت کنید که
$\delta,\gamma$
پارامتر های این الگوریتم هستند که توسط \on تعیین میشوند.
هرچه
$\delta,\gamma$
بزرگ تر باشند، الگوریتم \on به ازای هر افزایش در 
$A(X_t)$
بیشتر به کانال پول اضافه میکند. 
همچنین 
$\delta$
تعیین میکند که عمل شارژ کردن کانال چقدر زود به زود انجام شود. اگر 
$\delta$
برابر
$0$
باشد آن گاه با کوچک ترین تغییر در 
$A(X_t)$,
شاخه \کد{if}
الگوریتم 
\رجوع{Algorithm:onlinetracker}
 فعال میشود و عمل شارژ کردن انجام میگیرد (که طبعا هزینه هم در پی دارد).
از طرفی اگر 
$\delta$
خیلی بزرگ باشد، در اولین شارژ کردن، \on مقدار زیادی پول به کانال اضافه میکند ولی مدت زمان خیلی زیادی طول میکشد تا 
$A(X_t)$
به
$\tracker$
برسد و دوباره شاخه \کد{if} فعال شود.


یک حالت خاص الگوریتم 
\کد{
$(\delta,\gamma)$-recharging
}
زمانی رخ میدهد که 
$\delta = 0$
و 
$\gamma = 1$.
 در این صورت الگوریتم دقیقا میزان 
$A(X_t)$
را دنبال میکند و 
$\tracker$
برابر مجموع پول موجود در کانال است. هرگاه پول موجود در کانال از 
$A(X_t)$
کمتر شود آنگاه الگوریتم موجودیش را افزایش میدهد تا آن را به 
$A(X_t)$
برساند. جدول مثالی از
\رجوع{tab:examplesequence}
میزان تغییر 
$\tracker$
و پول \on
را با تغییر
$A(X_i)$
نشان میدهد.

\کد{\input{chapters/algorithms/using_tracker.tex}}


\کد{
\begin{table}[htb!]
\centering
\begin{tabular}{||c c c||} 
 \hline
 $A(X_i)$ & $\tracker$ & Amount locked in the channel for \on \\ [0.5ex] 
 \hline\hline
 $0$ & $0$ & $0$ \\ 
 \hline
 $\eps$ & $\delta + \eps$ & $\gamma (\delta + \eps)$  \\
 \hline
 $\delta$ & $\delta + \eps$ & $\gamma (\delta + \eps)$ \\
 \hline
 $\delta+2\eps$ & $2(\delta + \eps)$ & $2\gamma (\delta + \eps)$ \\
 \hline
\end{tabular}
\caption{
An exampe of
$(\gamma, \delta)$- recharging
($\delta > \eps >0$)}
\label{tab:examplesequence}
\end{table}}



\شروع{لم} \برچسب{لم:هزینه الگوریتم ترکر}
الگوریتم 
\رجوع{Algorithm:onlinetracker}
تضمین میکند که همیشه \on حداقل 
$\gamma$
برابر \off
پول دارد و همچنین مجموع هزینه شارژ کردن درون بلاکچینی \on تا لحظه $t$ حداکثر برابر

$\gamma(A_t + \delta) + f_1 \cdot \lceil \frac{A_t}{\delta} \rceil$
است.
\پایان{لم}

\شروع{اثبات}
اگر $i$ یکی از لحظات شارژ کردن الگوریتم \رجوع{Algorithm:onlinetracker} باشد، موجودی کانال \on در این لحظه برابر است با
$\gamma(\tracker)$
و 
$\tracker = A(X_i)+\delta$
از طرفی به محض اینکه در لحظه $j > i$،
$\tracker < A(X_j)$
رخ دهد دوباره عمل شارژ شدن انجام میگیرد. پس در تمام لحظات 
$i \leq k < j $
، پول موجود در کانال بیشتر از $\gamma$ برابر 
$A(X_k)$
است پس بخش اول قضیه درست است.


برای به دست آوردن هزینه ای که \on برای شارژ کردن کانال تا لحظه $t$ متحمل میشود، اولا دقت کنید در این لحظه \on ماکسیمم 
$\gamma(A(X_t)+\delta)$
پول در کانال دارد (با فرض اینکه دقیقا در بدترین حالت در لحظه $t$ عمل شارژ کردن را انجام داده). پس 
$F_{total}(t)$
که مجموع پولی است که \on با شارژ کردن درون بلاکچینی تا لحظه $t$ به کانال خود اضافه کرده در رابطه زیر صدق میکند:
$$F_{total}(t) \leq \gamma(A(X_t)+\delta)$$
حالا باید ببینیم حداکثر چندبار عمل شارژ کردن انجام شده تا بتوانیم مجموع هزینه ثابتی (یعنی
$f_1$
)که \on برای شارژ کردن ها پرداخته را محاسبه کنیم. 
اگر برای هر
$i<t$
داشته باشیم
$A(X_{i+1}) = A(X_{i}) + \delta $
آن گاه برای همه تراکنش ها شاخه \کد{if}
الگوریتم 
\رجوع{Algorithm:onlinetracker} فعال میشود و \on در این صورت باید به ازای هر تراکنش شارژ کردن را انجام دهد و
 $f_1$
را بپردازد که در این صورت بیشترین هزینه ثابت را متحمل میشود.
. این اتفاق حداکثر 
$\lceil\frac{A(X_t)}{\delta}\rceil$
تعداد بار رخ میدهد و در نتیجه هزینه ثابت \on حداکثر
$f_1\lceil\frac{A(X_t)}{\delta}\rceil$
خواهد بود. در نتیجه هزینه کلی \on کمتر یا برابر خواهد بود با :

$$F_{total}(t) + f_1\lceil\frac{A(X_t)}{\delta}\rceil \leq \gamma(A(X_t)+\delta) + f_1\lceil\frac{A(X_t)}{\delta}\rceil$$
\پایان{اثبات}



\شروع{لم} \برچسب{لم:هزینه الگوریتم آفلاین} اگر 
$A(X_t) > 0$
آن گاه برای هزینه الگوریتم \off
داریم:
$\costoff(X_t) \geq A(X_t) + f_1$.
\پایان{لم}
\شروع{اثبات}
 اولا نشان میدهیم که هزینه \off با گذر زمان یا تغییر نمیکند یا بیشتر میشود یعنی دنباله
$\costoff(X_t)$
یک دنباله صعودی در زمان است، به طور خاص نشان میدهیم اگر اضافه شدن 
$x_{t+1}$
به دنباله 
$X_t$
باعث شود که
$\costoff(X_{t+1}) < \costoff(X_{t}) $
این امر با بهینه بودن الگوریتم \off تناقض دارد: دقت کنید که
$\costoff(X_{t+1})$
شامل هزینه تراکنش های 
$x_1,\dots,x_t$
به اضافه هزینه 
$x_{t+1}$
است. هزینه  پردازش
$x_{t+1}$
همواره بزرگ تر مساوی صفر است (صفر در حالت داشتن موجودی کافی و پذیرش، در غیر این صورت اکیدا بزرگ تر از صفر).
پس نزولی بودن 
$\costoff(X_{t})$
نشان دهنده این است که الگوریتم در لحظه
$t+1$
هزینه اکیدا کمتری برای پردازش تراکنش های 
$x_1,\dots,x_t$
میپردازد که این با بهینه بودن \off در تمام لحظات تناقض دارد. 
با داشتن این نکته در ذهن حالا میتوان تحلیل کرد که اگر 
$A(X_t) > 0$
یعنی \off حداقل یکبار کانال را در لحظه ی
 $t_0 < t$
به اندازه
$A(X_t)$
شارژ کرده پس داریم:
$$\costoff(X_t) \geq \costoff(X_{t_0}) \geq A(X_t) + f_1$$
\پایان{اثبات}





%\subsection{زیر مساله 1 : کانال یکطرفه بدون امکان رد تراکنش} 


%\subsection{زیر مساله 2 : کانال یکطرفه با امکان رد تراکنش} 

\قسمت{توصیف الگوریتم مساله کانال دو طرفه}
در این قسمت کلی ترین حالت مساله را در نظر میگیریم که در آن دو کاربر 
$\ell , r$
با همکاری هم میخواهند مجموع هزینه های کانالشان را کمینه کنند. به دنبال الگوریتم آنلاین \con هستیم که در هر لحظه $i$ با مشاهده تراکنش
$x_i$
و دانستن موجودی کانال در این لحظه ابتدا تابع 
$\Call{Funds}{X_i}$ 
فراخوانی میکند و سپس 
$y_i, rech_i , reb_i$
را به عنوان خروجی تحویل میدهد.
 اول از همه دقت کنید که در این بخش فرض میکنیم که 
$R=0$
 است یعنی هزینه رد کردن تراکنش یک هزینه ثابت 
$f_2$
 و هزینه متعادل کردن برون بلاکچینی هم برابر مقدار ثابت
$Cf_2$
است. در بخش \رجوع{}  میبنیم که با توجه به مقدار بسیار کوچک
$R$
در شبکه های واقعی، صفر فرض کردن این مقدار از واقع بینانه بودن مدل چندان نمیکاهد اما در عوض به دستیابی به نتایج تئوری کمک چشمگیری میکند.

الگوریتم \رجوع{Algorithm:logC-competitive-main} الگوریتم اصلی ما را نشان میدهد. این الگوریتم از 3 زیر الگوریتم استفاده میکند، اولا در دل خود الگوریتم  \رجوع{Algorithm:logC-competitive-main} الگوریتم \کد{
$(\delta,\gamma)$-recharging}
با مقادیر 
$\delta = f_1 , \gamma = 4+2\lceil \log{C}\rceil$
اجرا میشود. ثانیا در الگوریتم  \رجوع{Algorithm:logC-competitive-main}  دو تابع 
$\Call{DECIDE}{.}$ 
و
$\Call{HANDLEFUNDS}{.}$ 
فراخوانی میشود که توصیف این توابع را به ترتیب در الگوریتم های
\رجوع{Algorithm:decide_on_trx}  و \رجوع{Algorithm:handle-fund} میتوانید مشاهده کنید.
\کد{\input{chapters/algorithms/decide_on_trx.tex}}
\کد{\input{chapters/algorithms/handle_fund.tex}}
\کد{\input{chapters/algorithms/main_algorithm.tex}}
الگوریتم \رجوع{Algorithm:logC-competitive-main} را خط به خط توضیح میدهیم. در خط \رجوع{mainalg:newTRx}، الگوریتم \on، یک تراکنش جدید دریافت کرده و آن را به دنباله تراکنش هایی که تاکنون دیده است اضافه میکند. سپس تابع 
$\Call{Funds}{X}$
را فراخوانی میکند و با منطقی دقیقا مشابه با الگوریتم \رجوع{Algorithm:onlinetracker}، اگر 
$\tracker < \Call{Funds}{X}$
آن گاه
$\tracker$
را آپدیت میکند:
$\tracker \leftarrow  \Call{Funds}{X} + f_1$
 و موجودی کانال را به اندازه ای افزایش میدهد که در کانال در مجموع
$(4+2\lceil \log{C}\rceil)\tracker$
پول باشد. در اینجا لازم است در خط \رجوع{mainalg:recharge} الگوریتم توقفی داشته باشیم و توضیح دهیم که \on چگونه پول جدید را بین $\ell$ و $r$ تقسیم میکند. \on در هر سمت کانال 
$\lceil \log{C}\rceil + 2$
\bucket
در نظر میگیرد. در این پایان نامه از کلمه \bucket به معنی یک ظرفی با ظرفیت تعیین شده (متغیر با زمان) استفاده میکنیم که در آن میتوان تا سقف ظرفیتش پول ریخت و این پول برای پذیرفتن تراکنش هایی گه در یک رنج خاص هستند استفاده میشود. \bucket های سمت راست کانال را با 
$B^{r}_{s}, B^{r}_{1},B^{r}_{2},\dots,B^{r}_{\lceil\log{C}\rceil},B^{r}_{o}$
و مشابها \bucket های سمت چپ کانال را با 
$B^{\ell}_{s}, B^{\ell}_{1},B^{\ell}_{2},\dots,B^{\ell}_{\lceil\log{C}\rceil},B^{\ell}_{o}$
نمایش میدهیم. ظرفیت \bucket های 
$B^{\ell}_{s},B^{r}_{s}$
برابر 
$2\tracker$
است، ظرفیت \bucket های 
$B^{r}_{1},B^{r}_{2},\dots,B^{r}_{\lceil\log{C}\rceil}$ و $B^{\ell}_{1},B^{\ell}_{2},\dots,B^{\ell}_{\lceil\log{C}\rceil}$
برابر 
$\tracker$
است و \bucket های 
$B^{\ell}_{o},B^{r}_{o}$
ظرفیت مشخصی ندارند و میتوانند به هر اندازه پر شوند.

در خط \رجوع{mainalg:recharge} الگوریتم \رجوع{Algorithm:logC-competitive-main}  وقتی عمل شارژ کردن انجام میشود همه \bucket های سمت راست و چپ به جز 
$B^{\ell}_{o},B^{r}_{o}$
به اندازه ظرفیتشان پر میشوند.
 
اگر بخواهیم پیش از دقیق شدن در سایر گام های الگوریتم یک شهود کلی نسبت به دلیل وجودی \bucket ها بدهیم میتوان گفت که \bucket های 
$B^{\ell}_{s},B^{r}_{s}$
بودجه پذیرش تراکنش هایی با اندازه کوچکتر مساوی 
$\frac{\tracker}{C}$
در سمت راست و چپ هستند و  \bucket های 
$B^{r}_{i},B^{\ell}_{i} , i \in \{1,2,\dots,\lceil\log{C}\rceil-1\}$
برای پذیرش تراکنش هایی با اندازه
$\frac{\tracker}{2^{i-1}}<x\leq \frac{\tracker}{2^{i}}$
استفاده میشوند. همچنین \bucket های

$B_{\lceil\log{C}\rceil}^{\ell} ,B_{\lceil\log{C}\rceil}^{r}  $
برای پذیرش تراکنش های بازه
$\frac{\tracker}{C}<x\leq \frac{\tracker}{2^{\lceil\log{C}\rceil}-1}$
استفاده میشوند.
 \bucket های 
$B^{\ell}_{o},B^{r}_{o}$ 
هم پول های اضافه (سرریز) را در صورت وجود نگه میدارند و بعدا اگر هر کدام از \bucket های دیگر خالی شدند، به آنها پول انتقال میدهند.
دقت کنید که \bucket ها یک مفهوم کاملا انتزاعی هستند به این معنی که صرفا \on آنها را در نظر میگیرد تا بتواند بودجه اش را با برنامه ریزی قبلی به تراکنش ها اختصاص دهد. جابجایی پول بین \bucket های یک سمت کانال هیچ هزینه ای ندارد اما جابجایی پول از \bucket های یک سمت کانال به سمت دیگر، تنها با اسال تراکنش به آن سمت یا با متعادل کردن برون بلاکچینی امکان پذیر است که البته در ادامه هنگام توصیف الگوریتم های \رجوع{Algorithm:decide_on_trx}  و \رجوع{Algorithm:handle-fund}  توضیحات دقیق تری درباره \bucket ها و نحوه استفاده و پر کردن آنها میدهیم.

در خطوط  \رجوع{mainalg:beforeDecide1} تا  \رجوع{mainalg:beforeDecide2}، بسته به جهت تراکنش فرستنده و گیرنده مشخص میشود و بعد در خط \رجوع{mainalg:decide} تابع 
$ \Call{Decide}{\tracker ,x , B^{sdr},  B^{rcv}}$
فراخوانی میشود. 
$B^{sdr} ,  B^{rcv}$
به ترتیب مجموعه \bucket های فرستنده و گیرنده را نمایش میدهند.
از این به بعد به توصیف تابع
$ \Call{Decide}{.}$
میپردازیم. هدف این تابع این است که با گرفتن وضعیت \bucket ها و اندازه تراکنش تصمیم بگیرد که تراکنش را بپذیرد یا خیر و بسته به پذیرش یا عدم پذیرش موجودی \bucket ها را هم بروزرسانی کند.
بسته به اندازه تراکنش دو حالت وجود دارد. یا تراکنش در بازه مربوط به یکی از \bucket های 
$B_i^{sdr} \quad i \in [1,\lceil\log{C}\rceil]$
قرار دارد که در این صورت تراکنش تنها در حالتی پذیرفته میشود که \bucket
$B_i^{sdr}$
پول کافی برای پذیرش آن داشته باشد. خطوط  \رجوع{decidealg:Bibucket1} تا \رجوع{decidealg:Bibucket2} الگوریتم  \رجوع{Algorithm:decide_on_trx}  مربوط به این حالت است.
پس از پذیرش تراکنش موجودی 
$B_i^{sdr}$
 به اندازه $x$ کم میشود ولی بلافاصله \bucket
$B_o^{sdr}$
بررسی میشود تا اگر پول سرریزی در آن موجود است این پول به 
$B_i^{sdr}$
منتقل شود و آن را تا سقف ظرفیتش یعنی
$\tracker$
پر کند.

خط های \رجوع{decidealg:Bsbucket1} تا \رجوع{decidealg:Bsbucket2}  الگوریتم  \رجوع{Algorithm:decide_on_trx}  به بررسی تراکنش هایی میپردازد که اندازه آنها کمتر از 

$\frac{\tracker}{C}$
است و موجودی \bucket 

$B_s^{sdr}$
برای پذیرش $x$ کافیست.
در این صورت تراکنش پذیرفته میشود، پول از 
$B_s^{sdr}$
کم میشود و بلافاصله بررسی میشود تا اگر پول اضافه ای در 
$B_o^{sdr}$
موجود بود، 
$B_s^{sdr}$
را تا سرحد ظرفیتش یعنی 

$2\tracker$
پر کند. 
خط های  \رجوع{decidealg:Bsbucket3} تا \رجوع{decidealg:Bsbucket4}  الگوریتم  \رجوع{Algorithm:decide_on_trx}  حالتی را بررسی میکند که اندازه تراکنش کوچک تر از 
$\frac{\tracker}{C}$
است و موجودی 
$B_s^{sdr}$
برای پذیرش کافی نیست. در این صورت بر خلاف تراکنش های بزرگ تر که رد میشند، \on عمل متعادل کردن درون بلاکچینی را انجام میدهد تا پول کافی در سمت فرستنده داشته باشد و بتواند تراکنش را بپذیرد. 
در اثبات ضریب رقابتی الگوریتم خواهیم دید که چرا \on تراکنش های کوچک را بی قید و شرط میپذیرد. در واقع شهود کلی این است که \رجوع{}







\قسمت{اثبات ضریب رقابتی مساله کانال دو طرفه}
دو شارژ کردن درون بلاکچینی متوالی الگوریتم \on را به طور دلخواه در نظر بگیرید. زمان شارژ کردن اول را با
$t_1$
و زمان شارژ کردن بعدی را با 
$t_2$
نشان میدهیم. در بازه زمانی 
$[t_1,t_2)$
مقدار 
$\tracker$
و در نتیجه ظرفیت \bucket ها ثابت است و با توجه به خط \رجوع{mainalg:compare} الگوریتم  \رجوع{Algorithm:logC-competitive-main} میدانیم که مجموع کل پولی که \off در کانال دارد از 
$\tracker$
کم تر است. 

هزینه الگوریتم های \on و \off از چندین منبع مختلف ناشی میشود. 1) شارژ کردن درون بلاکچینی، آن را با
$\costoff^1(X) , \coston^1(X)$
نمایش میدهیم.
2) رد کردن تراکنش ها، این بخش از هزینه را با 
$\costoff^2(X) , \coston^2(X)$
نمایش میدهیم.   3) متعادل کردن برون بلاکچینی، این بخش هزینه را با

$\costoff^3(X) , \coston^3(X)$
نمایش میدهیم.

\شروع{لم}
با اجرای الگوریتم \رجوع{Algorithm:logC-competitive-main} برای هر لحظه
$t$
که در آن 
$A(X_t) > 0$
داریم :
\begin{equation}
\coston^1(X) \leq (5+2\lceil \log{C}\rceil)\costoff^1(X)
\end{equation}
\پایان{لم}

\شروع{اثبات}
با توجه به لم  \رجوع{لم:هزینه الگوریتم ترکر} میتوان نوشت:
\begin{equation}
\coston^1(X_t)  \leq \gamma(A_t + \delta) + f_1 \cdot \lceil \frac{A_t}{\delta} \rceil   \leq    \gamma(A_t + \delta) + f_1 \cdot ( \frac{A_t}{\delta} +1 )
\end{equation}
با جایگذاری 
$\delta = f_1 , \gamma = 4+2\lceil \log{C}\rceil$
داریم:
\begin{equation}
\coston^1(X_t)  \leq  (4+2\lceil \log{C}\rceil)\cdot(A_t + f_1) +  ( A_t + f_1 ) = (5+2\lceil \log{C}\rceil)\cdot(A_t + f_1)
\end{equation}
با استفاده از نتیجه لم \رجوع{لم:هزینه الگوریتم آفلاین} میتوان نوشت:
\begin{equation}
\coston^1(X_t) \leq (5+2\lceil \log{C}\rceil)\cdot(A_t + f_1) \leq (5+2\lceil \log{C}\rceil)\costoff^1(X_t)
\end{equation}

\پایان{اثبات}


\شروع{ادعا}\برچسب{ادعا:آفلاین حداکثر موجودی را دارد}
اگر فرض کنیم که در بازه
$ t \in [t_1,t_2)$
بین هر دو شارژ کردن متوالی الگوریتم \on، موجودی کانال \off یعنی 
$A(X_t)$
برابر متغیر
$\tracker$
در الگوریتم  \رجوع{Algorithm:logC-competitive-main} است، این فرض باعث کاهش هزینه محاسبه شده برای \off و در نتیجه افزایش ضریب رقابتی میشود.
\پایان{ادعا}
\شروع{اثبات}
همانطور که پیش از این گفتیم در بازه بین هر دو شارژ کردن الگوریتم \on ،موجودی کانال \off کمتر مساوی 
$\tracker$
است. از این پس برای سادگی فرض میکنیم
$A(X_{t}) = \tracker \quad \forall t \in [t_1,t_2)$
یعنی فرض میکنیم موجودی \off از همان ابتدای بازه ماکسیمم مقدار خود را دارد تا انتهای بازه. این کار تنها به نفع الگوریتم \off است و در محاسبه ضریب رقابتی مشکلی ایجاد نمیکند (فقط ضریب رقابتی را بیشتر میکند نه کمتر زیرا بیشترین توانایی ممکن را برای \off در نظر گرفته ایم). 
\پایان{اثبات}




\شروع{قضیه} اگر
$t_1$ و
$t_2$
دو زمان متوالی شارژ کردن کانال توسط الگوریتم \on (توصیف شده در الگوریتم \رجوع{Algorithm:logC-competitive-main} ) باشد آن گاه:
\begin{dmath}\برچسب{معادله:رابطه هزینه رد کردن و متعادل کردن}
\big(\coston^2(X_{t_2}) +\coston^3(X_{t_2})\big) -  \big(\coston^2(X_{t_1}) +\coston^3(X_{t_1})\big) \leq 2\cdot\Big(\big(\costoff^2(X_{t_2})+ \costoff^3(X_{t_2})\big)-\big(\costoff^2(X_{t_1})+ \costoff^3(X_{t_1})\big)\Big)
\end{dmath}
یعنی هزینه ای که \on صرف رد کردن تراکنش ها یا متعادل کردن کانال در بازه
$[t_1,t_2)$
میکند، حداکثر دو برابر هزینه ای است که \off صرف این کار میکند.
\پایان{قضیه}
\شروع{اثبات}
زمان بین 
$t_1$
تا 
$t_2$
را به چندین \epoch راست و \epoch چپ تقسیم میکنیم. زمانی که \on در سمت چپ کانال کمتر از 
$(2+\lceil\log{C}\rceil)\tracker$
پول دارد در یک \epoch چپ هستیم (یعنی حداقل یکی از \bucket های سمت چپ کمتر از ظرفیتش پول دارد) و برعکس زمانی که  \on در سمت راست کانال کمتر از 
$(2+\lceil\log{C}\rceil)\tracker$
پول دارد در یک \epoch راست هستیم (یعنی حداقل یکی از \bucket های سمت راست کمتر از ظرفیتش پول دارد). \epoch های راست و چپ با هم تداخل ندارند و کافیست یکی از \epoch ها را، مثلا یکی از \epoch های سمت چپ را در نظر بگیریم و نشان دهیم که هزینه های \on در این \epoch در سمت چپ کانال حداکثر دو برابر هزینه های \off است.
دقت کنید که در یک \epoch چپ، در سمت راست کانال همه \bucket ها پر هستند پس هر تراکنشی که 
$x \leq \tracker$
در سمت راست بیاید پذیرفته میشود و هزینه ای برای \on در بر ندارد و فقط لازم است هزینه های \on در سمت چپ کانال را بررسی کنیم.
همچنین دقت کنید که \off مجموعا در هر دو سمت کانال حداکثر به اندازه 
$\tracker$
پول دارد پس تراکنش های بزرگ تر از این مقدار را رد میکند و \on هم طبق الگوریتم آن ها را رد میکند پس میتوان این تراکنش ها را در نظر نگرفت.

پس میخواهیم نشان دهیم در هر \epoch دلخواه در  به طور مثال در سمت چپ (برای سمت راست هم اثبات مشابه است) هزینه ای که \on برای رد کردن تراکنش ها و متعادل کردن برون بلاکچینی انجام میدهد حداکثر دو برابر هزینه ای است که \off برای این امور میپردازد.
یک \epoch سمت چپ زمانی آغاز میشود که تمام \bucket های چپ پر باشند و تراکنشی از سمت چپ بیاید و از یکی از \bucket های چپ مقداری پول برداشته شود و موجودی 
$B_o^{\ell}$
برای پر کردن این \bucket کافی نباشد.

هزینه هر دو الگوریتم \off و \on را روی تراکنش هایی در رنج های مختلف (مربوط به \bucket های مختلف) مقایسه میکنیم.


\textbf{گام اول:}
اول تراکنش هایی که کوچک تر مساوی
$\frac{\tracker}{C}$
هستند و بودجه آنها از سبد 
$B_s^{\ell}$
تامین میشود را بررسی میکنیم. در ابتدای یک \epoch چپ
$B_s^{\ell}$
به اندازه 
$2\tracker$
پول دارد و هر تراکنشی در بازه 
$x \leq \frac{\tracker}{C}$
را میپذیرد تا زمانی که پولش تمام شود و آن گاه برای تراکنش بعدی ای که در این بازه بیاید عمل متعادل کردن برون بلاکچینی انجام میدهد، هزینه 
$Cf_2$
را برای این کار میپردازد و 
$B_s^{\ell}$
را به اندازه ای پر میکند که پس از پذیرفتن تراکنش با اندازه
$x$
موجودی باقی مانده در 
$B_s^{\ell}$
برابر
$2\tracker$
شود. 

نکته حاشیه ای : دقت کنید که انجام متعادل کردن برون بلاکچینی به اندازه ذکر شده برای \on همیشه امکان پذیر است زیرا اینکه
$B_s^{\ell} = a < x$
است نشان دهنده این است که 
$B_o^{r} \geq 2\tracker - a$
پس \on میتواند به اندازه
$2\tracker - a$
از 
$B_o^r$
بردارد و به اندازه 
$x$
از 
$B_s^r$
بردارد و بعد از پذیرش تراکنش چون مقدار 
$x$
از چپ به راست منتقل میشود دوباره 
$B_s^r$
پر خواهد شد.


حالا میخواهیم هزینه \off برای تراکنش های این بازه را بررسی کنیم. 
اولا یک نکته ی بسیار مهم را دقت کنید، در سمت راست کانال \on تمام تراکنش ها را دارد میپذیرد و پول این تراکنش ها در سمت چپ کانال طبق الگوریتم \رجوع{Algorithm:handle-fund}  وارد با الویت ترین \bucket یعنی 
$B_s^{\ell}$
میشود بنابراین میزان پولی که \on از سمت کانال دریافت میکند و برای پذیرش تراکنش های \bucket 
$B_s^{\ell}$
استفاده میکند بیشتر مساوی پولی است که \off از سمت راست کانال دریافت میکند.

وقتی \on متعادل کردن برون بلاکچینی انجام میدهد مجموع اندازه تراکنش هایی که در بازه
$x \leq \frac{\tracker}{C}$
آمده است تا قبل از این لحظه حداقل برابر 
$2\tracker$
بوده است. حتی با فرض اینکه \off در ابتدای \epoch همه پولش که حداکثر
$\tracker$
است در سمت چپ بوده، حداکثر تعدادی تراکنش که مجموع آنها
$\tracker$
بوده را توانسته بپذیرد و بقیه تراکنش ها را یا رد کرده است یا با انجام دادن متعادل کردن برون بلاکچینی آن ها یا بخشی از آن ها را پذیرفته است. اگر متعادل کردن برون بلاکچینی انجام داده باشد که در این صورت هزینه \off هم حداقل
$Cf_2$
بوده و در نتیجه هزینه \on برای این تراکنش ها کمتر مساوی هزینه \off است. اما اگر \off متعادل کردن برون بلاکچینی انجام نداده پس حتما تعدادی تراکنش که هر کدام کوچکتر مساوی
$\frac{\tracker}{C}$
هستند و جمعشان حداقل
$\tracker$
بوده را رد کرده است. تعداد این تراکنش ها حداقل 
$\frac{\tracker}{\frac{\tracker}{C}}=C$
عدد بوده در نتیجه \off برای رد کردن آنها حداقل
$Cf_2$
پرداخته. پس در هر شرایطی هزینه \off بیشتر مساوی هزینه \on بوده است. با منطق مشابه میتوان نتیجه گرفت که از ابتدا تا انتهای \epoch، هزینه \off برای پردازش تراکنش های مربوط به سبد بودجه
$B_s^{\ell}$
بیشتر مساوی هزینه \on برای پردازش این تراکنش هاست.


\textbf{گام دوم:}
حالا هزینه \on و \off روی تراکنش هایی را بررسی میکنیم که در محدوده

$(\frac{\tracker}{C},\frac{\tracker}{2^{\lceil\log{C}\rceil-1}}]$
هستند. زمان رسیدن اولین تراکنش این بازه به سمت چپ کانال را
$t'$
و زمان رسیدن آخرین تراکنش این بازه را
$t''$
مینامیم.
موجودی
$B_{\lceil\log{C}\rceil}^{\ell}$
در ابتدای \epoch برابر با
$\tracker$
است و \on این پول را برای پذیرش تراکنش هایی که بازه مربوطه هستند خرج میکند تا زمانی که این \bucket خالی شود، پس از آن \on تا زمانی که پول کافی در 
$B_{\lceil\log{C}\rceil}^{\ell}$
برای پذیرش تراکنش های این بازه نداشته باشد، آن ها را رد میکند تا زمانی که از سمت راست پول برسد و به موجودی
$B_{\lceil\log{C}\rceil}^{\ell}$
اضافه کند. نکته مهم این است که \on هیچگاه برای پذیرش تراکنش هایی که در این بازه هستند متعادل کردن برون بلاکچینی انجام نمیدهد.



فرض ساده کننده این گام:  فرض کنید که در تمام زمان بین
$[t',t'']$,
$B_s^{\ell}$
کاملا پر است و خالی هم نمیشود (یعنی تلویحا در این مدت تراکنشی برای \bucket
$B_s^{\ell}$
از سمت چپ نمی آید).

با داشتن این فرض ساده کننده میتوانیم سه نتیجه ی خیلی مهم بگیریم:\\
1) پولی که 
\on 
 برای پذیرفتن تراکنش های بازه
$(\frac{\tracker}{C},\frac{\tracker}{2^{\lceil\log{C}\rceil-1}}]$
در لحظه
$t'$
اختصاص داده است حداقل برابر کل پولی است که \off در این لحظه در سمت چپ کانال دارد. زیرا موجودی 
$B_{\lceil\log{C}\rceil}^{\ell}$
برابر 
$\tracker$
است که بیشتر از کل پولی است که \off در هر دو طرف کانال دارد.\\
2) پولی که با پذیرفتن تراکنش های سمت راست توسط \on به \bucket
$B_{\lceil\log{C}\rceil}^{\ell}$
اضافه میشود بیشتر از پولی است که \off  با پذیرفتن تراکنش های سمت راست کانال در سمت چپ بدست می آورد. دلیل این ادعا این است که  چون \on تمام تراکنش های سمت راست را میپذیرد و چون
$B_s^{\ell}$
در تمام این مدت کاملا پر است پس تمام پولی که از سمت راست می آید به
$B_{\lceil\log{C}\rceil}^{\ell}$
اضافه میشود. (برای یادآوری به الگوریتم\رجوع{Algorithm:handle-fund} مراجعه کنید.)\\
3) \off
در بازه زمانی 
$[t',t'']$
به هیچ وجه تعادل کردن برون بلاکچینی انجام نمیدهد. دلیل این امر این است که فرض کردیم در این مدت همه تراکنش ها بزرگ تر از
$\frac{\tracker}{C}$
هستند. در واقع \off هیچ گاه برای پذیرش تراکنش هایی که همه آن ها مقدار بزرگ از 
$\frac{\tracker}{C}$
دارند متعادل کردن برون بلاکچینی انجام نمیدهد زیرا هزینه متعادل کردن برون بلاکچینی 
$Cf_2$
است و با این کار \off میتواند حداکثر
$\tracker$
پول را از یک سمت به سمت دیگر ببرد و در نتیجه کمتر از 
$C$
تراکنش را در این بازه قبول کند که این نتیجه میدهد که بهتر است که به جای متعادل کردن برون بلاکچینی \off همه این تراکنش ها را رد کند و هزینه کمتری متحمل
$Cf_2$ 
شود. در نتیجه میتوان گفت که \off هم مشابه \on اگر پولش تمام شود تراکنش های این بازه را رد میکند. 

نتیجه نهایی 3 نکته بالا این است که در مجموع در بازه 
$[t',t'']$
\on بیشتر مساوی
\off پول برای پذیرش تراکنش های
مربوط به \bucket
$B_{\lceil\log{C}\rceil}^{\ell}$
دارد.
حالا به این نکته دقت کنید که تراکنش هایی که مربوط به این \bucket هستند در بازه
$\frac{\tracker}{C}< x \leq \frac{\tracker}{2^{\lceil\log{C}\rceil-1}}$
قرار دارند، یعنی کوچک ترین تراکنش این بازه نصف بزرگ ترین تراکنش آن است. بدترین دنباله تراکنش ممکن که نسبت تعداد تراکنش های رد شده توسط
\on 
 به تعداد تراکنش های رد شده توسط \off را ماکسیمم میکند
از جنس دنباله زیر است:
\begin{equation}
\{\underbrace{\frac{\tracker}{2^{\lceil\log{C}\rceil-1}} , \frac{\tracker}{2^{\lceil\log{C}\rceil-1}} \dots,}_{2^{\lceil\log{C}\rceil-1}}\underbrace{\frac{\tracker}{C} , \frac{\tracker}{C} , \dots}_{C}\}
\end{equation}
که با دیدن آن \on
$2^{\lceil\log{C}\rceil-1}$
تراکنش اول را میپذیرد و پولش تمام میشود و مجبور میشود
$C$
تراکنش بعدی را رد کند اما \off دقیقا برعکس عمل میکند. پس برای این دسته از تراکنش ها خواهیم داشت:
\begin{dmath}
\frac{\coston^2(X_{t_2})  -  \coston^2(X_{t_1})}{\costoff^2(X_{t_2})  -  \costoff^2(X_{t_1})} \leq \frac{C}{2^{\lceil\log{C}\rceil-1}} \leq 2
\end{dmath}
پس در گام دوم نشان دادیم با داشتن فرض ساده کننده ای که در بالا ذکر شد هزینه رد کردن تراکنش ها برای \on حداکثر دو برابر \off است و همچنین نشان دادیم با داشتن فرض مذکور \off در این بازه متعادل کردن برون بلاکچینی انجام نمیدهد پس رابطه \رجوع{معادله:رابطه هزینه رد کردن و متعادل کردن} به طور خاص برای تراکنش های \bucket
$B_{\lceil\log{C}\rceil}^{\ell}$
برقرار است.

\textbf{گام سوم:}
حالا میخواهیم در این گام نشان دهیم چگونه با حذف کردن فرض ساده کننده ی گام 2 همچنان به نتیجه مطلوب برسیم. به صورت کلی در بازه 
$[t',t'']$
ممکن است تراکنش هایی برای \bucket
$B_s^{\ell}$
به سمت چپ کانال برسد و با پذیرفته شدن این تراکنش ها
$B_s^{\ell}$
سرخالی شود و در نتیجه اگر تراکنشی از سمت راست آمد،
$B_s^{\ell}$
را با الویت بیشتری نسبت به
$B_{\lceil\log{C}\rceil}^{\ell}$
پر کند.  \\
حذف کردن فرض ساده کننده، حل کردن چالش اول) فرض کنید در لحظه ای در بازه
$[t',t'']$،
$B_s^{\ell}$
به اندازه

$a < \tracker$
سرخالی است، پس اگر تراکنشی از سمت راست بیاید تا سقف
$a$
مقدار از آن به
$B_s^{\ell}$
اضافه میشود.
اینکه
$B_s^{\ell}$
سرخالی است به این معنی است که قبلا تراکنش یا تراکنش هایی کوچکتر مساوی
$\frac{\tracker}{C}$
با مجموع مقدار
$a$
به سمت چپ کانال ارسال شده است، اگر \off این تراکنش ها را پذیرفته باشد پس دربازه $[t',t'']$ به اندازه $a$ از بودجه \off برای پذیرفتن تراکنش های سبد
$B_{\lceil\log{C}\rceil}^{\ell}$
 پول کم شده است و در بهترین حالت \off
به اندازه
$\tracker - a$
بودجه برای پذیرش تراکنش های این سبد 
دارد. با آمدن تراکنش هایی از راست به چپ \off ممکن است بتواند این مقدار $a$ را برای پذیرفتن تراکنش های بعدی استفاده کند و در این صورت بودجه اش برای پذیرفتن تراکنش های 
$B_{\lceil\log{C}\rceil}^{\ell}$  
را به 
$\tracker$
افزایش دهد. اما دقت کنید که الگوریتم \on برای 
$B_{\lceil\log{C}\rceil}^{\ell}$ 
از همان ابتدا مقدار بودجه
$\tracker$
اختصاص داده بود پس در مجموع بودجه ای که \on برای پذیرفتن تراکنش های \bucket
$B_{\lceil\log{C}\rceil}^{\ell}$ 
اختصاص میدهد بیشتر مساوی \off است.

حالا حالتی را بررسی میکنیم که \off این تراکنش های کوچکتر مساوی
$\frac{\tracker}{C}$
با مجموع مقدار
$a$
را رد کرده است. در این صورت بودجه اولیه \off برای پذیرش تراکنش های \bucket
$B_{\lceil\log{C}\rceil}^{\ell}$ 
میتواند همانند \on برابر 
$\tracker$
باشد و بعدا با آمدن تراکنش های راست به چپ ممکن است بودجه \off تا
$\tracker + a$
هم افزایش پیدا کند در حالیکه بودجه \on همان 
$\tracker$ 
باقی می ماند و این ممکن است \on را ناچار کندکه تراکنش هایی از سبد
$B_{\lceil\log{C}\rceil}^{\ell}$ 
با مجموع هزینه
$a$
را رد کند در حالیکه \off آنها را میپذیرد. بگذارید هزینه هایی که \on و \off برای رد کردن تراکنش های مذبور میپردازند را مقایسه کنیم:
\off تعدادی تراکنش با مجموع مقدار
$a$
را از سبد 
$B_{s}^{\ell}$
حذف کرده است پس هزینه رد کردنش حداقل برابر
$f_2\frac{aC}{\tracker}$ 
در حالیکه هزینه رد کردن تعدادی تراکنش با مجموع
$a$
 توسط \on از سبد 
$B_{\lceil\log{C}\rceil}^{\ell}$ 
از این مقدار اکیدا کم تر است (زیرا تراکنش های این سبد بزرگ تر هستند). در نتیجه با احتساب هزینه های رد کردن، بودجه زیاد تر \off کمکی به کمتر کردن هزینه هایش نمیکند و میتوان بودجه اضافی \off به مقدار
$a$
را در نظر نگرفت (زیرا فقط باعث افزایش هزینه اش در سمت چپ میشود) و فرض کرد هر دو \on و \off بودجه یکسان
$\tracker$
را دارند پس از اثبات گام 2 میتوان استفاده کرد.

به طور کلی میتوان نتیجه گرفت زمانی که \bucket
$B_{j}^{\ell}$
سرخالی است، استفاده از پول تراکنش های راست به چپ برای پذیرش تراکنش هایی که مربوط به سبد های
$B_{k}^{\ell}, \;k < j $
هستند، تنها باعث افزایش هزینه \off در سمت چپ کانال میشود. \\
حذف کردن فرض ساده کننده، قدم دوم) اگر تراکنش های کوچک تر از
$\frac{\tracker}{C}$
در بازه زمانی
$[t',t'']$
در سمت چپ کانال داشته باشیم، آن گاه انجام دادن متعادل کردن برون بلاکچینی ممکن است برای \off سودبخش باشد و با انجام این کار بتواند تعدادی تراکنش از دسته
$T_s$
بپذیرد که آن ها را با 
$\zeta_{s}$
نشان میدهیم و تعدادی تراکنش از دسته
$T_{\lceil\log{C}\rceil}$
که آن ها را با
$\zeta_{\lceil\log{C}\rceil}$
نشان میدهیم.
به زبان دیگر \off میتواند با متعادل کردن برون بلاکچینی بودجه اش برای پذیرش تراکنش های 
$T_{\lceil\log{C}\rceil}$
را زیاد کند در حالیکه \on هیچ گاه برای این دسته از تراکنش ها متعادل کردن برون بلاکچینی انجام نمیدهد.
باید بررسی کنیم که در این صورت \on آیا این تراکنش ها را میپذیرد یا خیر و اگر نمیپذیرد آیا این امر باعث افزایش هزینه اش میشود یا خیر. نشان میدهیم که انجام متعادل کردن برون بلاکچینی برای پذیرش برخی از تراکنش های 
$T_{\lceil\log{C}\rceil}$
همیشه هزینه \off را  به اندازه
$Cf_2$
زیاد میکند اما هزینه \on را اکیدا کمتر از این مقدار اضافه میکند. اگر
$B_s^{\ell} \geq \tracker$
آن گاه \on میتواند همه تراکنش های 
$\zeta_{s}$
را بدون هیچ هزینه ای بپذیرد و حتی اگر مجبور به رد کردن تراکنش های 
$\zeta_{\lceil\log{C}\rceil}$
هم شود باز هم چون این تراکنش ها بزرگ تر 
$\frac{\tracker}{C}$
هستند و مجموعشان کمتر از
$\tracker$
است هزینه رد کردنشان کمتر از
$Cf_2$
خواهد شد.
اما اگر 
$B_s^{\ell} < \sum_{x \in \zeta_{s}} x < \tracker$
آن گاه \on متعادل کردن برون بلاکچینی انجام میدهد تا تراکنش های
$\zeta_{s}$
را بپذیرد و هزینه
$Cf_2$
را میپردازد، به علاوه برای رد کردن تراکنش های 
$\zeta_{\lceil\log{C}\rceil}$
هم مقداری کمتر از 
$Cf_2$
میپردازد.
اما نکته ای که باید دقت کرد این است که چون 
$B_s^{\ell} < \tracker$
پس پیش از این \off حداقل یکبار به اندازه 
$Cf_2$
هزینه داده است و در مجموع برای پردازش تمام تراکنش های 
$T_s$
تا این لحظه و تراکنش های
$\zeta_{\lceil\log{C}\rceil}$
حداقل 
$2Cf_2$
هزینه کرده است در حالیکه هزینه ای که \on برای پردازش تراکنش های 
$T_s$
تا این لحظه و تراکنش 
$\zeta_{\lceil\log{C}\rceil}$
پرداخت کرده است کمتر مساوی
$2Cf_2$
است.




















\پایان{اثبات}








